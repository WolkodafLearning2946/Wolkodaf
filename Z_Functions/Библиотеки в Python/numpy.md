> [!info]+ Импорт библиотеки
> ```py
> import numpy as np
> ```
> `np` - псевдоним, то есть можно поставить любой свой, но именно такой используется сообществом программистов

Библиотека `numpy` работает с объектами-массивами, которые способны хранить много значений и быть многомерными. При этом, в отличие от списков, **массивы могут хранить только значения одного типа**. За счёт этого массивы в `numpy` **занимают меньше памяти и работают быстре**е, чем списки.

>[!code]+ Создать массив можно разными способами. 
>Один из них — использовать функцию `array()`
>==" array(\*список) "== - функция, преобразующая список в массив.
>Для доступа к элементам массива необходимо указать индекс элемента в квадратных скобках.
>```py
> import numpy as np
> 
> a = np.array([1, 2, 3, 4])
> b = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])
> print(f"a[0] = {a[0]}")
> print(f"b[0] = {b[0]}")
>```
> > [!output]+
> > ```py
> > a[0] = 1
> > b[0] = [1 2]
> > ```

В терминологии `numpy` массив `a` имеет **одну ось** (термин «axis» из документации) <u>длиной четыре элемента</u>, 
а массив `b` имеет **две оси**: <u>первая имеет длину 4, а длина второй оси равна 2.</u>

Массивы `numpy` являются объектами класса `ndarray`.
> [!abstract]+ Наиболее важными атрибутами класса `ndarray` являются:
> - `ndarray.ndim` — размерность (количество осей) массива;
> - `ndarray.shape` — кортеж, значения которого содержат количество элементов по каждой из осей массива;
> - `ndarray.size` — общее количество элементов массива;
> - `ndarray.dtype` — объект, описывающий тип данных элементов массива;
> - `ndarray.itemsize` — размер памяти в байтах, занимаемый одним элементом массива.
> 
> > [!code]+
> >```py
> > import numpy as np
> > 
> > a = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])
> > print(f"a.ndim = {a.ndim}, a.shape = {a.shape}, a.size = {a.size}, a.dtype = {a.dtype}")
> > ```
> > >[!output]+
> > >```py
> > > a.ndim = 2, a.shape = (4, 2), a.size = 8, a.dtype = int32
> > > ```

Встроенные в `numpy` типы данных **аналогичны типам данных в языке программирования С**. Например, в предыдущем примере мы создали массив со значениями типа `int32`, то есть целые числа со знаком *(отрицательные и положительные)* и размером занимаемой <u>памяти 32 бита</u>. Из ограничения в размере памяти для типов данных в `numpy` следует то, что массивы каждого типа данных могут хранить значения из определённого диапазона. Например, для `int32` этот числовой диапазон составляет **от -2 147 483 648 до 2 147 483 647**.

**Покажем на примере, что произойдёт, если попытаться записать значение не из диапазона для типа данных.** 
Для этого создадим массив типа `uint8` — целые числа без знака размером 8 бит. Диапазон значений для этого типа **от 0 до 255**. Тип данных можно указать через именованный аргумент `dtype` при создании массива:

> [!code]+
> ```python
> import numpy as np
> 
> a = np.array([1, 2, 3], dtype="uint8")
> a[0] = 256
> print(a)
> ```
> > [!output]+
> > ```py
> > OverflowError: Python integer 256 out of bounds for uint8
> > ```

При создании массива без указания его типа в аргументе `dtype` библиотека `numpy` попытается привести его к тому типу данных, который сможет хранить все значения исходной коллекции.

> [!code]+ Рассмотрим пример:
> ```python
> import numpy as np  
>   
> a = np.array([1, 2.5, 3])  
> print(a)  
> print(a.dtype)  
> b = np.array(['text', 1, 2.5])  
> print(b)  
> print(b.dtype)
> ```
> > [!output]+
> > ```
> > [1.  2.5 3. ]
> > float64
> > ['text' '1' '2.5']
> > <U32
> > ```

В примере для массива `a` был выбран тип данных `float64`, так как **исходный список содержит вещественное число**. 

Для массива `b` был выбран тип данных <u>&lt;U32</u>, который может хранить строки в кодировке Unicode длиной 32 символа. **Такой тип данных был выбран, поскольку в исходной коллекции есть элемент-строка.**

---

Для создания массива из нулей используется функция `np.zeros()`, которая принимает кортеж с количеством чисел, соответствующим количеству осей массива, а значения в кортеже — количество элементов по каждой из осей.

> [!code]+
> ```py
> import numpy as np  
>   
> a = np.zeros((4, 3))  
> print(a)  
> print()  
> a = np.zeros((4, 3), dtype="int32")  
> print(a)
> ```
> > [!output]+
> > ```py
> > [[0. 0. 0.]
> >  [0. 0. 0.]
> >  [0. 0. 0.]
> >  [0. 0. 0.]]
> > 
> > [[0 0 0]
> >  [0 0 0]
> >  [0 0 0]
> >  [0 0 0]]
> > ```

Функция `np.ones()` создаёт массив аналогично функции `np.zeros()`, только из элементов-единиц.

> [!code]+
> ```py
> import numpy as np
> 
> a = np.ones((4, 3))
> print(a)
> ```
> > [!output]+
> > ```py
> > [[1. 1. 1.]
> >  [1. 1. 1.]
> >  [1. 1. 1.]
> >  [1. 1. 1.]]
> > ```

Функция `np.eye()` создаёт единичную матрицу, то есть массив с единицами на главной диагонали и нулевыми остальными элементами:

> [!code]+
> ```py
> import numpy as np
> 
> a = np.eye(5, 5, dtype="int8")
> print(a)
> ```
> > [!output]+
> > ```py
> > [[1 0 0 0 0]
> >  [0 1 0 0 0]
> >  [0 0 1 0 0]
> >  [0 0 0 1 0]
> >  [0 0 0 0 1]]
> > ```

Для создания массива, заполненного значениями из диапазона, используется функция `np.arange()`. Эта функция похожа на стандартную функцию `range()`, но возвращает массив и может создавать диапазон значений из вещественных чисел.

> [!code]+
> ```py
> import numpy as np
> 
> a = np.arange(1, 10)
> print(a)
> print()
> a = np.arange(1, 5, 0.4)
> print(a)
> ```
> > [!output]+
> > ```py
> > [1 2 3 4 5 6 7 8 9]
> > 
> > [1.  1.4 1.8 2.2 2.6 3.  3.4 3.8 4.2 4.6]
> > ```

Функция `np.linspace()` создаёт массив из заданного количества вещественных равномерно распределённых значений из указанного диапазона.

> [!code]+
> ```py
> import numpy as np
> 
> a = np.linspace(1, 5, 10)  # задаётся начало, конец диапазона и количество значений
> print(a)
> ```
> > [!output]+
> > ```py
> > [1.         1.44444444 1.88888889 2.33333333 2.77777778 3.22222222
> >  3.66666667 4.11111111 4.55555556 5.        ]
> > ```

Для изменения размерности массива используется функция `reshape()`. Она принимает кортеж, значения которого задают новые размеры массива по осям. Функция `reshape()` возвращает новый массив. 
**Обратите внимание:** при изменении размерности количество элементов в массиве не должно измениться.

> [!code]+
> ```py
> import numpy as np
> 
> a = np.zeros((4, 3), dtype="uint8")
> print(a)
> print()
> a = a.reshape((2, 6))
> print(a)
> ```
> > [!output]+
> > ```py
> > [[0 0 0]
> >  [0 0 0]
> >  [0 0 0]
> >  [0 0 0]]
> > 
> > [[0 0 0 0 0 0]
> >  [0 0 0 0 0 0]]
> > ```

Метод `resize()` меняет размерность исходного массива:

> [!code]+
> ```py
> import numpy as np
> 
> a = np.zeros((4, 3), dtype="uint8")
> print(a)
> print()
> a.resize((2, 2, 3))
> print(a)
> ```
> > [!output]+
> > ```py
> >[[0 0 0]
> >  [0 0 0]
> >  [0 0 0]
> >  [0 0 0]]
> > 
> > [[[0 0 0]
> >   [0 0 0]]
> > 
> >  [[0 0 0]
> >   [0 0 0]]]
> > ```

Если при изменении размерности в функции `reshape()` указать значение -1 по одной или нескольким осям, то значения размерности рассчитаются автоматически:
> [!code]+
> ```py
> import numpy as np
> 
> a = np.zeros((4, 3), dtype="uint8")
> print(a)
> print()
> a = a.reshape((2, 3, -1))
> print(a)
> ```
> > [!output]+
> > ```py
> > [[0 0 0]
> >  [0 0 0]
> >  [0 0 0]
> >  [0 0 0]]
> > 
> > [[[0 0]
> >   [0 0]
> >   [0 0]]
> > 
> >  [[0 0]
> >   [0 0]
> >   [0 0]]]
> > ```

Для работы с массивами доступны все стандартные арифметические операции, а также тригонометрические, экспоненциальная и другие функции. Выполнение математических операций над массивами происходит поэлементно. Размерность массивов должна совпадать при выполнении этих операций.

> [!code]+
> ```py
> import numpy as np
> 
> a = np.array([9, 8, 7])
> b = np.array([1, 2, 3])
> print(a + b)
> print(a - b)
> print(a * b)
> print(a / b)
> ```
> > [!output]+
> > ```py
> > [10 10 10]
> > [8 6 4]
> > [ 9 16 21]
> > [9.         4.         2.33333333]
> > ```

Для умножения матриц используется операция `@` или функция `dot`:

> [!code]+
> ```py
> import numpy as np
> 
> a = np.array([[1, 2, 3],
>               [4, 5, 6],
>               [7, 8, 9]])
> b = np.array([[0, 0, 1],
>               [0, 1, 0],
>               [1, 0, 0]])
> print(a @ b)
> ```
> > [!output]+
> > ```py
> > [[3 2 1]
> >  [6 5 4]
> >  [9 8 7]]
> > ```

Матрицы можно транспонировать функцией `transpose()` и поворачивать функцией `rot90()`. При повороте можно указать направление поворота вторым аргументом:

> [!code]+
> ```py
> import numpy as np
> 
> a = np.arange(1, 13).reshape(4, 3)
> print(a)
> print("Транспонирование")
> print(a.transpose())
> print("Поворот влево")
> print(np.rot90(a))
> print("Поворот вправо")
> print(np.rot90(a, -1))
> ```
> > [!output]+
> > ```py
> > [[ 1  2  3]
> >  [ 4  5  6]
> >  [ 7  8  9]
> >  [10 11 12]]
> > Транспонирование
> > [[ 1  4  7 10]
> >  [ 2  5  8 11]
> >  [ 3  6  9 12]]
> > Поворот влево
> > [[ 3  6  9 12]
> >  [ 2  5  8 11]
> >  [ 1  4  7 10]]
> > Поворот вправо
> > [[10  7  4  1]
> >  [11  8  5  2]
> >  [12  9  6  3]]
> > ```

Функции вычисления суммы элементов массива, поиска минимального и максимального элементов и многие другие по умолчанию работают для всех элементов массива, не учитывая размерность:

> [!code]+
> ```py
> import numpy as np
> 
> a = np.array([[1, 2, 3],
>              [4, 5, 6],
>              [7, 8, 9]])
> print(a.sum())
> print(a.min())
> print(a.max())
> ```
> > [!output]+
> > ```py
> > 45
> > 1
> > 9
> > ```

Дополнительно в указанных функциях можно указать номер оси (индексация с 0), на которой будет работать функция:

> [!code]+
> ```py
> import numpy as np
> 
> a = np.array([[1, 2, 3],
>               [4, 5, 6],
>               [7, 8, 9]])
> print(a.sum(axis=0))  # сумма чисел в каждом столбце
> print(a.sum(axis=1))  # сумма чисел в каждой строке
> print(a.min(axis=0))  # минимум по столбцам
> print(a.max(axis=1))  # максимум по строкам
> ```
> > [!output]+
> > ```py
> > [12 15 18]
> > [ 6 15 24]
> > [1 2 3]
> > [3 6 9]
> > ```

В массивах можно брать срез. Для одномерных массивов эта операция аналогична стандартному срезу в Python. Для многомерного массива можно задавать диапазон среза отдельно для каждой оси. Таким образом, можно взять срез отдельной части матрицы, указав, какие строки и столбцы должны попасть в срез:

> [!code]+
> ```python
> import numpy as np
> 
> a = np.arange(1, 13).reshape(3, 4)
> print(a)
> print()
> print(a[:2, 2:])
> print()
> print(a[:, ::2])
> ```
> > [!output]+
> > ```py
> > [[ 1  2  3  4]
> >  [ 5  6  7  8]
> >  [ 9 10 11 12]]
> > 
> > [[3 4]
> >  [7 8]]
> > 
> > [[ 1  3]
> >  [ 5  7]
> >  [ 9 11]]
> > ```

В цикле `for` можно пройти по элементам первой оси массива:

> [!code]+
> ```py
> import numpy as np
> 
> a = np.arange(1, 13).reshape(3, 4)
> print(a)
> for row in a:
>     print(row)
> ```
> > [!output]+
> > ```py
> > [[ 1  2  3  4]
> >  [ 5  6  7  8]
> >  [ 9 10 11 12]]
> > 
> > [1 2 3 4]
> > [5 6 7 8]
> > [ 9 10 11 12]
> > ```

Для линеаризации многомерного массива можно использовать атрибут `flat`, который является итератором, возвращающим последовательно значения массива:

> [!code]+
> ```py
> import numpy as np
> 
> a = np.arange(1, 13).reshape(3, 4)
> print(a)
> print()
> print("; ".join(str(el) for el in a.flat))
> ```
> > [!output]+
> > ```py
> > [[ 1  2  3  4]
> >  [ 5  6  7  8]
> >  [ 9 10 11 12]]
> > 
> > 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12
> > ```

---
# Дополнительная информация
В `numpy` существуют и другие встроенные типы данных. С ними можно ознакомиться в [документации](https://numpy.org/doc/stable/user/basics.types.html).
































