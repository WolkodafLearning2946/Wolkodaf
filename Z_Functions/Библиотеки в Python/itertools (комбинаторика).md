> [!info]+ For what?
> Модуль стандартизирует основной набор быстрых, эффективных в использовании памяти инструментов, которые полезны сами по себе или в сочетании. Вместе они образуют **«алгебру итераторов»**, что позволяет создавать специализированные инструменты лаконично и эффективно на чистом Python

> [!info]+ Определение
> <u>Итератор</u> — это **специальные объекты, которые позволяют получать элементы коллекции один за другим, без необходимости знать внутреннюю структуру данных** (вызвали и сразу же забыли)
### Бесконечные итераторы

**Бесконечные итераторы:**

|Итератор|Аргументы|Результаты|Пример|
|---|---|---|---|
|`count()`|[начало[, шаг]]|старт, старт+шаг, старт+2*шаг, …|`count(10) → 10 11 12 13 14 ...`|
|`cycle()`|p|р0, р1, … p.last, р0, р1, …|`cycle('ABCD') → A B C D A B C D ...`|
|`repeat()`|элемент [,n]|элемент, элемент, элемент, … бесконечно или до n раз|`repeat(10, 3) → 10 10 10`|

**Итераторы, завершающиеся на самой короткой входной последовательности:**

|Итератор|Аргументы|Результаты|Пример|
|---|---|---|---|
|`accumulate()`|p [,функ]|р0, р0+р1, р0+р1+р2, …|`accumulate([1,2,3,4,5]) → 1 3 6 10 15`|
|`batched()`|п, н|(p0, p1, …, p_n-1), …|`batched('ABCDEFG', n=3) → ABC DEF G`|
|`chain()`|п, д, …|p0, p1, … пласт, q0, q1, …|`chain('ABC', 'DEF') → A B C D E F`|
|`chain.from_iterable()`|повторяемый|p0, p1, … пласт, q0, q1, …|`chain.from_iterable(['ABC', 'DEF']) → A B C D E F`|
|`compress()`|данные, селекторы|(d[0] если s[0]), (d[1] если s[1]), …|`compress('ABCDEF', [1,0,1,0,1,1]) → A C E F`|
|`dropwhile()`|предикат, послед.|seq[n], seq[n+1], начиная с момента, когда предикат терпит неудачу|`dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8`|
|`filterfalse()`|предикат, послед.|элементы seq, где predicate(elem) не выполняется|`filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8`|
|`groupby()`|итерируемый[, ключ]|подытераторы, сгруппированные по значению ключа(v)|`groupby(['A','B','DEF'], len) → (1, A B) (3, DEF)`|
|`islice()`|последовательность, [старт,] стоп [, шаг]|элементы из seq[start:stop:step]|`islice('ABCDEFG', 2, None) → C D E F G`|
|`pairwise()`|повторяемый|(п[0], п[1]), (п[1], п[2])|`pairwise('ABCDEFG') → AB BC CD DE EF FG`|
|`starmap()`|функция, последовательность|функция(*seq[0]), функция(*seq[1]), …|`starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000`|
|`takewhile()`|предикат, послед.|seq[0], seq[1], пока предикат не выполнится|`takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4`|
|`tee()`|это, н|it1, it2, … itn разбивает один итератор на n||
|`zip_longest()`|п, д, …|(p[0], q[0]), (p[1], q[1]), …|`zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-`|
# Для ЕГЭ

==" from itertools import combinations "== - создаёт список из заданных комбинаций из заданного алфавита с заданной длиной

==" combinations "== - все возможные комбинации

> [!example]+ Код
> ```py
from itertools import combinations
cmb = list(combinations("АБВ", 2)) # алфавит, длина
print( cmb )
>```
> > [!abstract]+ Вывод:
> > ```py
> > [("А", "Б"), ("А", "В"), ("Б", "В")]
> > ```

==" permutations "== - все возможные перестановки
> [!example]+ Код
> ```py
from itertools import permutations
cmb = list(permutations('ABC')) # алфавит. Тут также можно указать длину элемента перестановок
print( cmb )
>```
> > [!abstract]+ Вывод:
> > ```py
> > [('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), ('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')]
> > ```

==" product "== - декартово произведение (все возможные слова заданной длины, составленные из данного алфавита)

> [!example]+ Код
> ```py
> from itertools import permutations 
> cmb = list(product('ABC', repeat=2)) 
> print( cmb )
> ```
> > [!abstract]+ Вывод:
> > ```py
> > [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B','B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C','C')]
> > ```

---

==" cycle "== - принимает на вход итерируемый объект, а возвращает итератор, который бесконечно циклически перебирает значения коллекции

> [!example]+  Программа, которая выводит строку длиной 10 символов, циклически перебирая символы входной строки ABC: 
> ```py
> from itertools import cycle 
>
>max_len = 10
>s = ""
>for letter in cycle("ABC"):
>	if len(s) < max_len:
>		s += letter
>	else:
>		break
>print(s)
> ```
> > [!abstract]+ Вывод:
> > ```py
> > ABCABCABCA
> > ```


---
<h2> Склейка </h2>

> [!example]+ Код
> ```py
> from itertools import product
> a=[]
> cmb = product('ABC', repeat=2)
># [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B','B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C','C')]
> for i in cmb:
> 	s = "".join(i)
> 	#соединяет буквы каждого элемента массива
> 	a.append(s)
> print (a)
> ```
> > [!abstract]+ Вывод:
> > ```py
> > ['AA', 'AB', 'AC', 'BA', 'BB', 'BC', 'CA', 'CB', 'CC']
> > ```

