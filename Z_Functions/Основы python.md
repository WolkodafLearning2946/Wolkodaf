### Библиотеки
==import math== - подключить [[math|математический модуль]]
==import random== - подключить функции [[random (генератор случайных чисел)|генератора случайных чисел]]
==import turtle== - [[ЕГЭ-6 Черепашка|графическая библиотека]]

---
### [[1. Арифметические выражения|Арифметические программы]]
==" \ "==  - перенос кода на следующую строку
==" / "== - классическое деление
==" // "== - целочисленное деление (округление "вниз"!)
==" % "== - остаток от деления

==" abs(x) "== - модуль числа  
==" int(x) "== - преобразование к целому числу  
==" round(x) "== - округление
==" type(значение для проверки) "== - возвращает тип данных введённого значения (числа, строки, вещественные числа, логические выражения True/False)

---
### [[Основы Python/1. Простейшие программы/1. Комментарий|Комментарий]]
==#== - закомментировать одну строку кода
=='''== - закомментировать несколько строк кода

---
### [[Основы Python/1. Простейшие программы/2. Вывод на экран|Вывод на экран]]
==print()== - функция для печати аргументов, указанных в скобках
==" , "== - ставит автоматический пробел
==sep = ""== - Убрать разделители
==end== - необязательный [[4. Позиционные и именованные аргументы. Функции высших порядков.|параметр]] в функции `print()`**,** и его значением по умолчанию является `\n`, что означает, что **print()** по умолчанию заканчивается новой строкой.
==f-строки==
==" \n "== - переводит выводимый текст на следующую строку

---
### [[4. Ввод значений с клавиатуры|Ввод значений с клавиатуры]]
==input()== - это готовая функция для ввода данных с клавиатуры.
==A.split()==  - разделить строку на части с пробелами
Функция ==map()==

---
### [[1. Условный оператор|Условный оператор]]
==" if "== - Функция условия  
=='' else "== - Если условие не выполняется, то...
==" elif "== = else if
==" max( элементы, из которых нужно вычислить ) "== - Функция, которая находит **_максимальное_** число из тех, что указаны в скобках  
==" min( элементы, из которых нужно вычислить ) "== - Функция, которая находит **_минимальное_** число из тех, что указаны в скобках

> [!note]+ Знаки отношений
> ==">"==, =="<"== - Больше, меньше  
==" >= "== - Больше или равно  
==" <= "== - Меньше или равно  
==" == "== - Равно  
==" != "== - Не равно

> [!note]+ Сложные условия
> ==" and "== - "И"  
==" or "== - "ИЛИ"  
==" (not()) "== - "НЕ..."

==" match / case "== - оператор, который сокращает условия
==" ord("символ") "== - возвращает код символа в кодировке
==" chr(код элемента) "== - возвращает символ по коду

---
### [[2. Логический тип данных (True, False)|Логический тип данных (True, False)]]
==" True "== - специальное обозначение (класса < "bool" >), означающее "Правда". ==1==
==" False "== - специальное обозначение (класса < "bool" >), означающее "Ложь". ==0==

==" bool() "== - функция, которая нужна, чтобы приводить другие типы данных к булевому типу

---
### [[1. Цикл|Циклы]]
==" while "== - цикл, который выполняется, пока не будет выполнено указанное условия
==" while True: "== - бесконечный цикл
==" for "== - цикл, который используется, когда известно, сколько раз необходимо выполнить алгоритм
==" range(\*от чего(включительно, \*до чего(невключительно), \*шаг) "== - функция, возвращающая последовательность чисел, начиная с 0 по умолчанию, с шагом 1 (по умолчанию) и останавливаясь перед указанным числом.
==" pass "== - самостоятельная инструкция (процедура), которая буквально ничего не делает
==" := "== - позволяет одновременно вычислить выражение, присвоить результат переменной и вернуть это значение
==" continue "== - оператор, который используется для пропуска текущего блока и перехода к следующей итерации
==" break "== - оператор, который полностью завершает цикл. Если он вызывается, остальные итерации не выполняются
==" else "== - оператор, который выполняется, когда цикл завершился. ВНИМАНИЕ! `else` в цикле отличается от `else` в операторе `if`

---
### [[1. Строки|Строки]]
==" len( чью длину нужно найти ) "== - функция, которая находит длину строки
==" A[ от чего : до чего : шаг] "== - Срез строки
==" A.upper() "== - переводит все **_строчные_** буквы в строке в **_заглавные_**  
==" A.lower() "== - переводит все **_заглавные_** буквы в строке в **_строчные_**
==" A.isdigit() "== - функция, которая проверяет строку на цифры

==" A.replase( заменить" ", на " ", столько раз " " ) "== - функция, которая заменяет элементы в строке
==" A.count( " элемент ") "== - функция, которая в строке подсчитывает кол-во указанных элементов

==" A.islower() "== - метод, который проверяет, что в строке не встречаются заглавные буквы (возвращает **_"True"_**). Если же есть заглавные буквы, то возвращает **_"False"_**
==" A.capitalize() "== - Возвращает копию строки, у которой первая буква заглавная, а остальные строчные
==" A.endswith( подстрока из строки ) "== - возвращает True, если строка оканчивается на подстроку, указанную в скобках. Иначе возвращает False
==" A.isalnum() "== - возвращает True, если все символы строки являются буквами и цифрами и в строке есть хотя бы один символ. Иначе возdращает False
==" A.isalpha() "== - возвращает True, если все символы строки являются цифрами и в строке есть хотя бы один символ. Иначе возвращает False
==" eval( строка ) "== - Функция. Выполняет строку-выражение, переданную ей в качестве обязательного аргумента и возвращает результат выполнения этой строки.
==" isdigit() "== - проверка строки на наличие цифр

---
### [[2. Операции с массивами|Списки]]

==" A = list( элементы ) "== - функция, создающая список
==" A.index() "== - метод, возвращающий индекс заданного элемента
==" A[ от чего : до чего : шаг] "== - Срез
=="x in A"== - Возвращает True, если в списке s есть элемент x. Иначе False
==" x not in A"== - Возвращает False, если в списке s есть элемент x. Иначе True
=="x is A"== - Возвращает True, если значения равны и идентичны. Иначе False  
=="x is not A"== - Возвращает True, если значения не равны и не идентичны. Иначе False
==" A.count(x) "== - Возвращает количество элементов x
==" A.append(x) "== - Добавляет элемент x в конец списка
==" A.clear() "== - Удаляет все элементы списка
==" A.extend(B) "== - Расширяет список A элементами списка B
==" insert(индекс, значение) "== - добавляет значение в определённый индекс
==" A.pop(i) "== - Возвращает и удаляет элемент с индексом i. Если i не указан, то возвращается и удаляется последний элемент
==" A.remove(x) "== - Удаляет первый элемент со значением x
==" A.reverse() "== - Перестраивает элементы списка в обратном порядке
==" A.sort() "== - Cортирует список по возрастанию, ==меняя== исходный список
==" A.sort(reverse = True) "== - Сортирует список по убыванию, ==меняя== исходный список
==" sorted(A)"== - Возвращает отсортированный по возрастанию список, ==не меняя== исходный. Для сортировки по убыванию используется дополнительный аргумент `reverse=True`
==" A.copy() "== - Возвращает копию списка A

---
### [[1. Множества|Множества]]
==" set() "== - неупорядоченная коллекция уникальных элементов (множество)
==" in "== - проверяет, принадлежит ли элемент строке, списку, множеству или словарю.
==" union() "== или ==" | "== - Логическое "ИЛИ" (дизъюнкция)
==" intersection "== или ==" & "== - Логическое "И" (конъюнкция)
==" difference "== или =="-"== - Логическое "ВЫЧИТАНИЕ"
==" symmetric_difference "== или =="^"== - Логическое "ИСКЛЮЧАЮЩЕЕ ИЛИ"

> [!note]+ Операции сравнений множеств
> ==" == "== - **_Совпадение двух множеств_**
>==" <= "== - ***Подмножество***. Все элементы первого множества есть во втором
>==" >= "== - ***Надмножество***. Первое множество содержит все элементы второго

==" set.add(*элементы*) "== - Добавить элемент в множество
==" set.remove(*элементы*) "== - Удалить элемент множества. Возвращает исключение KeyError, если элемент не принадлежит множеству
==" set.discard(*элементы*) "== - Удалить элемент, если он принадлежит множеству
==" set.pop() "== - Вернуть и удалить произвольный элемент множества
==" set.clear() "== - Очистить множество, удалив все его элементы


---
## [[2. Словари|Словари]]
<mark style="background-color:#580297">" dict() "</mark> - [[2. Словари|словарь]]. Словарь похож на список, но вместо индексов элементов в словаре используются ключи, а по ключам в словаре хранятся значения.
<mark style="background-color:#580297">" len(d) "</mark> - Возвращает количество ключей в словаре
<mark style="background-color:#580297">" del d[key] "</mark> - Удалить ключ из словаря. Если ключа нет, то вызывается исключение **KeyError**
<mark style="background-color:#580297">" dict.clear() "</mark> - Удалить все ключи и значения в словаре
<mark style="background-color:#580297">" dict.copy() "</mark> - Возвращает копию словаря
<mark style="background-color:#580297">" dict.get(key, default) "</mark> - Возвращает значение по ключу key. Если ключа нет, то возвращает значение default
<mark style="background-color:#580297">" dict.items() "</mark> - Возвращает итерируемый объект, состоящий из кортежей (ключ, значение) словаря
<mark style="background-color:#580297">" dict.keys() "</mark> - Возвращает итерируемый объект, состоящий из ключей словаря
<mark style="background-color:#580297">" d.pop(key, default) "</mark> - Возвращает значение по ключу key и удаляет его из словаря. Если ключа нет, то возвращает default
<mark style="background-color:#580297">" dict.values() "</mark> - Возвращает итерируемый объект, состоящий из значений словаря
<mark style="background-color:#580297">" dict.setdefault( ключ, значение) "</mark> - Позволяет создать ключ словаря (если этот ключ не существует в этом словаре), а если указанный ключ существует, то этому ключу должно быть **задано или назначено значение по умолчанию**.


---
## [[1. Процедуры|Процедуры]] и [[Основы Python/7. Процедуры и функции/2. Функции|функции]]

==" def "== - фрагмент кода, который выполняет определённые операции и отдаёт результат
==" return "== - передача результата из выполненной функции
==" global "== - позволяет изменять переменную за пределами текущей области видимости
==" filter() "== - позволяет отобрать элементы из итерируемого объекта по некоторому критерию
<mark style="background-color:#580297">" lambda "</mark> - (Лямбда-функции) безымянные функции, которые используются один раз в коде функции и которые могут включать только одно выражение