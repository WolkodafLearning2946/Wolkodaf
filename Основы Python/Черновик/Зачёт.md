# **Перечень вопросов для подготовки:**

## Простейшие программы

> [!info]+ Комментарий
> ```py
> # Этот код не читается
> '''
> Этот код тоже не читается
> '''
> ```

> [!info]+ Переменные
> **Переменная** - это величина, имеющая имя, тип и значение.
> #### Типы переменных:
> 
> ```mermaid
> graph TB
> boxa([Типы переменных]) --> boxb([Строковые 'str'])
> boxa([Типы переменных]) --> boxc([Числовые ])
> boxa([Типы переменных]) --> boxd([Логические 'bool'])
> boxc([Числовые]) --> boxy([Целые 'int'])
> boxc([Числовые]) --> boxi([Вещественные 'float'])
> ```
> ```py
> a = 4 # < ' int ' > - целое число
> a = 4.5 # < ' float ' > - вещественное число
> a = "Hello" # < ' str '> - символьная строка
> a = True # < ' bool ' > - булево значение
> ```

==Функция== - алгоритм, составленный на языке программирования и имеющий уникальное имя.

> [!info]+ Вывод на экран
> ```py
> print(value, sep=' ', end='\n' )
> ```
> `value` - значения
> `sep` - разделитель
> `end` - конец строки
> 
> ---
> #### f - строки
> > [!example]+ Код
> > ```py
> > name = "Пользователь"
> > print(f"Добрый день, {name}. ")
> > ```
> > > [!abstract]+ Вывод:
> > > `Добрый день, Пользователь`

> [!info]+ Ввод значений
> ```py
> variable = input('*подсказка')
> ```
> #### Ввод нескольких значений в одной строке
> ```py
> # Можно так:
> 	a, b = int(input()), int(input())
> # А можно так:
> 	a, b = map (int, input().split())
> ```

## Вычисления
> [!abstract]+ Арифметические выражения
> ==" + "== - сложение
> ==" - "== - вычитание
> ==" * "== - умножение
> ==" / "== - классическое деление
> ==" // "== - целочисленное деление
> ==" % "== - остаток от деления
> ==" ** "== - возведение в степень
> > [!example]+ Сокращённая запись
> > ```py
> > a += b
> > a -= b
> > a *= b
> > a /= b
> > a //= b
> > a %= b
> > ```
> 
> >[!star]+ Приоритеты выполнения
> >![[Pasted image 20241010210215.png]]
> >$$ a =\frac{c + b^5 * 3 - 1 }{2} * d$$
> >1) Скобки
> >2) Возведение в степень
> >3) Умножение и деление
> >4) Сложение и вычитание
> 
> > [!warning]+ Вещественные числа разделяются <u>точкой</u>
> > ```py
> > a = 3.5
> > ```

## Условный оператор

==" if "== - Функция условия. Если выражение == True, то выполняется блок кода.
=='' else "== - Если условие не выполняется, то...

> [!example]+ Пример кода
> ```py
> if a > b:
> 	M = a #отступ на tab
> else:
> 	M = b #отступ на tab
> ```
> ```py
> M = a if a > b else b
> ```

==" max() "== - Функция, которая находит ***максимальное*** число из тех, что указаны в скобках
==" min() "== - Функция, которая находит ***минимальное*** число из тех, что указаны в скобках

> [!abstract]+ Знаки отношений
> ==">"==, =="<"== - Больше, меньше
> ==" >= "== - Больше или равно
> ==" <= "== - Меньше или равно
> ==" == "== - Равно
> ==" != "== - Не равно
## Сложные условия

>[!code]+
> ```py
> if v >= 25 and v <= 40: # Сложное условие
> 	print("подходит")
> else:
> 	print("не подходит")

> [!abstract]+ Сложные условия
> ==" and "== - "И"
> ==" or "== - "ИЛИ"
> ==" (not()) "== - "НЕ..."

>[!star]+ Приоритет:
> 1) отношение (" < ", " > " , " <= " , "=>" , " != ")
> 2) `not`
> 3) `and`
> 4) `or`
## Множественный выбор
`elif` == else if. Используется, когда есть второе условие, которое нужно проверить, если условие блока `if` не было выполнено (=False)

>[!code]+
>```py
>hour = 14
>if hour < 12:
>	print("Good morning")
>elif hour < 17:
>	print("Good afternoon")
>```

## Цикл с условием
==" while "== - [[1. Цикл|цикл]], который выполняется, пока условие внутри цикла = True

>[!code]+ Цикл с предусловием
>```py
> count = 0
> while count < 10: #while *условие*:
> 	print( "Привет")
> 	count += 1
>```

==" while True: "== - бесконечный [[1. Цикл|цикл]], из которого можно выйти с помощью функции ==" break "==

>[!code]+ Цикл с постусловием
>```py
> while True: #Бесконечный цикл
> 	#Тело цикла
> 	print( "Введите положительное число:")
> 	n = int(input())
> 	if n > 0: break #n > 0 - условие выхода; break - прервать цикл
>```

- При входе в цикл условие ***не проверяется***
- Цикл всегда выполняется ***хотя бы один раз***
## Цикл с переменной
==" for "== - [[1. Цикл|цикл]], который используется, когда известно, сколько раз необходимо выполнить алгоритм
> [!question]+ Problem
> Вывести 10 раз слово "Привет!"
>> [!code]+
> >```py
> >for i in range(10): #в диапазоне [0,10)
> >	print("Привет!")
> >```
> >> [!output]+
> >> ```py
> >> Привет!
> >> Привет!
> >> ... (ещё 8 раз)
> >> ```

***range(10)*** --> k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9; **Не включая 10!**
### Пустая инструкция
==" pass "== - самостоятельная инструкция (процедура), которая буквально ничего не делает
```py
saved_password = 'right_password'
while input('Введите пароль для входа: ') != saved_password:
	pass
print('Пароль верный. Вход разрешён.')
```
Пользователю будет выводиться "Введите пароль для входа: ", пока он не напишет то, что обозначено в переменной "saved_password"
### Моржовый оператор
==" := "== - позволяет одновременно вычислить выражение, присвоить результат переменной и вернуть это значение
> [!warning]+ Без оператора
> ```py
> name = input('Введите имя: ')
> while name != 'СТОП':
> 	print(f'Привет, {name}!")
> 	name = input("Введите имя: ")
> print("Программа завершена")

> [!success]+ С оператором
> ```py
>while (name := input("Введите имя: ")) != "СТОП":
>	print(f"Привет, {name}!")
>print("Программа завершена")
>```

## Вложенные циклы


## Процедуры

> [!info]+ Процедура ==" def *имя*() "==
> ***Процедура*** - вспомогательный алгоритм, который выполняет некоторые действия.
> 
> - текст (расшифровка) процедуры записывается **до** её вызова в основной программе
> - в программе может быть **много процедур**
> - чтобы процедура заработала, нужно **вызвать** её по имени из основной программы или из другой процедуры

==" def "== - [[Основы Python/7. Процедуры и функции/2. Функции|фрагмент кода, который выполняет определённые операции и отдаёт результат]]

> [!example]+ Требуется в коде много раз прописывать:
> `print("Ошибка программы")`
> >[!tip]+ define - процедура
> >```py
> >def Error(): # Error - своё название
> >	print("Ошибка программы")
> >```
> >```py
> >n = int(input())
> >if n < 0:
> >	Error() # Вызов процедуры
> >```
## Изменяемые параметры в процедурах

> [!info]+ Параметры
> Данные, изменяющие работу процедуры
> ```py
> def printBin(n):
> 	k = 128 # локальная переменная
> 	while k > 0:
> 		print(n//k, end="" )
> 		n = n % k
> 		k = k // 2
> ```
> ```py
> printBin(99) # значение праметра (аргумент)
> ```

> [!example]+ Несколько параметров
> ```py
> def printSred( a, b):
> 	print((a + b) / 2)
> ```

### Локальные и глобальные переменные
> [!example]+ Код
> ```py
> a=5 # - глобальная переменная
> def qq(): 
> 	a=1 # - локальная переменная
> 	print( a ) # a = 1
> qq() 
> print( a )
> ```
> ```py
> a=5 
> def qq(): 
> 	print( a ) # a = 5
> qq()
> ```

Глобальные переменные внутри процедур изменить нельзя, поэтому процедура сможет работать только с ними, что сразу делает процедуру бесполезной.

==" global "== - позволяет изменять переменную за пределами текущей области видимости

> [!example]+ Код
> ```py
> a=5
> def qq(): 
> 	global a # работаем с глобальной переменной
> 	a = 1
> qq() 
> print( a ) # a = 1
> ```
> 
## Функции

==" def "== - фрагмент кода, который выполняет определённые операции и отдаёт результат
```py
def имя_функции (аргументы):
    тело_функции
    return результат
```
==" return "== - передача результата из выполненной функции

> [!tip]+ Как вернуть несколько значений?
> ```py
> def divmod( x, y ):
> 	d = x // y
> 	m = x % y
> 	return d, m # Возвращает кортеж
> ```
> ```py
> a, b = divmod( 7, 3 )
> print( a, b ) # 2 1
> ```
> ```py
> q = divmod ( 7, 3 )
> print( q ) 
> # (2, 1) кортеж - набор элементов
> # 2 - q[0] , 1 - q[1]
> ```
## Логические функции
<u>Логические функции</u> - функции, которые возвращают 1 бит информации (True или False). Логические функции можно использовать так же, как и **любые условия**: *в условных операторах и циклах с условием.*
> [!example]+ Пример функции, которая возвращает логическое значение. Функция возвращает `True`, если число простое, и `False`, если оно составное
> ```py
> def is_prime(number):  
>    if number < 2:  
>        return False  
>  
>    for divisor in range(2, int(number ** 0.5) + 1):  
>        if number % divisor == 0:  
>            return False  
>  
>    return True  
> ```

## Рекурсия
> [!info]+ Definition
> **Рекурсия** - функция, которая в процессе выполнения вызывает саму себя на основе заданных простых базовых случаев
> > [!quote]+ Индуктивное определение
> > - 1 - натуральное число (база индукции)
> > - если $n$ - натуральное, то $n + 1$ - натуральное число

### Рекурсивные функции
> [!example]+ Числа Фибоначчи
> ```python
> def fib(n):
> 	if n in (0,1): # Базовый случай
> 		return 1
> 	return fib(n-1) + fib(n-2) # Рекурсия
>
>print(fib(4))
> ```
> > [!abstract]+ Output
> >```py
> > 5
> >```

> [!example]+ Факториал
> ```python
> def fact(n):
> 	if n == 0: # Базовый случай
> 		return 1
> 	return fact(n-1) * n # Рекурсия
>
>print(fact(5))
> ```
> > [!abstract]+ Output
> >```py
> > 120
> >```

---
#### Проблема рекурсий
Несмотря на то, что рекурсии более удобны, чем обычные функции и процедуры, **рекурсия будет выполняться больше по времени**. В чём причина?

<u>Проблема рекурсии</u>: внутри неё происходит два вызова самой себя для каждого значения. И так до тех пор, пока не дойдёт до начальных значений аргументов (1,1). В итоге появляется несколько рекурсивных веток:

![[Pasted image 20241220121351.png]]
Числа на схеме показывают номер числа Фибоначчи. Цветом показаны числа с одинаковым номером. Рекурсивная реализация функции выполняет много одинаковых вычислений

> [!info]+ Definition
><u>**Кеширование данных** (мемоизация)</u> - оптимизация процесса загрузки и обработки данных. **Это процесс хранения результатов выполнения функций** и запросов во временном хранилище (кэше) с целью ускорения повторного обращения к ним.
>
>---
>Вместо того чтобы заново выполнять те же операции, можно просто получить результат из кэша, что существенно экономит время и ресурсы.

> [!example]+ 
> Напишем рекурсивную функцию с кешированием, использовав для сохранения вычисленных значений [[2. Словари|словарь]], в котором ключами будут номера чисел последовательности, а значениями — сами числа.
> ```python
> def fib(n): 
> 	if n not in cash: 
> 		cash[n] = fib(n - 1) + fib(n - 2) 
> 	return cash[n]
> 	
> cash = {0: 1, 1: 1}
> ```
> За счёт кеширования количество вызовов рекурсивной функции существенно сократилось

---
### Глубина рекурсии
В Python по умолчанию максимальный размер глубины рекурсии равен 1000, поэтому, к примеру, если нам потребуется найти число Фибоначчи $>1000$, то выведется ошибка:
> [!example]+ 
> ```python
>def fib(n): 
>	if n not in cash: 
>		cash[n] = fib(n - 1) + fib(n - 2) 
>	return cash[n] 
>	
>cash = {0: 1, 1: 1}
>print(fib(2000))
> ```
> > [!abstract]+ Output
> >```python
> > RecursionError: maximum recursion depth exceeded
> >```

Чтобы изменить глубину рекурсии, нужно вызвать функцию `setrecursionlimit()` из стандартного модуля `sys` и передать новое значение для предела глубины
> [!example]+ 
> ```python
> from sys import setrecursionlimit 
> def fib(n): 
> 	if n not in cash: 
> 		cash[n] = fib(n - 1) + fib(n - 2) 
> 	return cash[n] 
> 	
> setrecursionlimit(3000) 
> cash = {0: 1, 1: 1}
> print(fib(2000))
> ```

> [!danger]+ 
> Максимально возможное значение глубины рекурсии **зависит от операционной системы**. Поэтому бесконечно его увеличивать не получится

## Стек
**Стек** — упорядоченная коллекция элементов, в которой добавление новых и удаление старых элементов всегда происходит с одного конца коллекции.
![[Pasted image 20250120011645.png]]
## Массивы. Перебор элементов массива
> [!info]+ Определение
> ***Массив*** - это группа переменных одного типа, расположенных в памяти рядом (в соседних ячейках) и имеющих общее имя. Каждая ячейка в массиве имеет уникальный номер (индекс).
> ```py
> # Массив:
> A = [ 5, 10, 15, 20, 25 ]
> ```

| ==0==    | ==1==    | ==2==    | ==3==    | ==4==    | ***Номер (индекс) элемента массива*** |
| -------- | -------- | -------- | -------- | -------- | ------------------------------------- |
| 5        | 10       | 15       | 20       | 25       | Значение элемента массива             |
| ==A[0]== | ==A[1]== | ==A[2]== | ==A[3]== | ==A[4]== | ***Как вызывается***                  |
```py
A = [1, 3] + [4, 23] + [5] 
# [1, 3, 4, 23, 5]

A = [0] * 10 
# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```
==" A = list( элементы ) "== - создание списка

> [!example]+ Генератор списков
> ```py
> A = [i for i in range(10) ]
> ```
> > [!abstract]+ Вывод:
> > ```py
> > [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
> > ```

---
### Вывод массива
> [!example]+ Как список:
> ```py
> print( A )
> ```
> > [!abstract]+ Вывод:
> >```py
> > [1, 2, 3, 4, 5]
> >```

> [!example]+ В строчку через пробел:
> ```py
> for i in range(N):
> 	print( A[i], end = " ")
> ```
> или так:
> ```py
> for x in A:
> 	print( x, end = " ")
> ```
> или так:
>  ```py
> print( *A )
> ```
> > [!abstract]+ Вывод:
> >```py
> > 1 2 3 4 5
> >```

---
### Перебор элементов в массиве

> [!tip]+ Общая схема (можно изменять A[i]):
> ```py
> for i in range(N):
> 	... # сделать что-то с A[i]
> ```
> > [!example]+ Пример
> > ```py
> > for i in range(N): 
> > 	A[i] += 1
> > ```

> [!tip]+ Если не нужно изменять A[i]:
> ```py
> for x in A:
> 	... # сделать что-то с x
> ```
> > [!example]+ Пример
> >```py
> >for x in A: 
> >	print ( x )
> >```

## Линейный поиск в массиве
**Линейный поиск** (также известный как последовательный поиск) — это алгоритм поиска элемента в списке или массиве, который последовательно проверяет каждый элемент до тех пор, пока не найдёт совпадение или не проверит все элементы.
```py
A = [1,2,3,4,5,6,7,8,9,0]
k = 7 #элемент, который нужно найти
index = 0

for i in A:
	if i == k:
		print(index)
		break
	index += 1
```

```py
# A - массив
# key - элемент, который нужно найти
def search(A, key):
    for i in range(len(A)):
        if A[i] == key:
            return True
    return False
```
## Поиск максимального элемента в массиве

> [!example]+ 
> ```py
> M = max(A)
> nMax = A.index(M)
> print( "A[", nMax, "]=", M, sep = "" )
> ```
## Алгоритмы обработки массивов (реверс, сдвиг)

![[Pasted image 20241207211241.png]]
> [!note]+ Алгоритм
> ```py
> for i in range( N // 2 ): 
> 	поменять местами A[i] и A [N-1-i]
> # N - количество элементов. Делим на два, ведь нужно идти до половины, иначе массив сделает реверс 2 раза.
> ```

> [!example]+ Решение в стиле Python
> ```py
>for i in range(N // 2):
>A[i], A[N-i-1] = A[N-i-1], A[i]
>```
>или так:
>```py
>A.reverse()
>```
><mark style="background-color:#580297">" A.reverse() "</mark> - метод, который позволяет изменять порядок элементов в списке на обратный

## Отбор элементов массива по условию

> [!question]+ Задача
> Отобрать элементы массива `A`, удовлетворяющие некоторому условию, в массив `B`

> [!example]+ 
> **Простое решение**
> ```py
> B = []
> for x in A:
> 	if x % 2 == 0: # Заданное для примера условие
> 		B.append(x)
> ```
> **Решение в стиле Python**
> ```py
> B = [ x for x in A if x % 2 == 0 ]
> # Перебрать все элементы A, где x - чётное число
> ```

## Сортировка массивов. Метод пузырька, выбора, быстрая сортировка

### Метод пузырька (сортировка обменами)

> [!question]+ Идея
> **Пузырек воздуха** в стакане воды **поднимается со дна вверх**
> 
> Для массивов– **самый маленький** («легкий» элемент **перемещается вверх** («всплывает»)
> > [!abstract]+ Алгоритм:
> > - Cравниваем два соседних элемента, если они стоят "неправильно", меняем их местами
> > - За 1 проход по массиву **один** элемент (самый маленький) становится на своё место
> 
> > [!example]+ Проходы:
> 1-й проход:
> ![[Pasted image 20241126002433.png]]
> 2-й проход:
> ![[Pasted image 20241126002457.png]]
> 3-й проход:
> ![[Pasted image 20241126002721.png]]
> 4-й проход:
> ![[Pasted image 20241126002842.png]]
> Для сортировки массива из **$N$** элементов нужен **$N-1$** проход (достаточно поставить на свои места **$N-1$** элементов)

> [!example]+ Code
> ```python
> A = [2,456,12,467,899,10,5555]
> N = len(A)
> 
> # Алгоритм:
> for i  in range(N-1):
> 	for j in range(N-2, i-1, -1):
> 		if A[j+1] < A[j]:
> 			A[j], A[j+1] = A[j+1], A[j]
> 			
> print(A)
> ```
> > [!abstract]+ Output:
> > ```py
> > [2, 10, 12, 456, 467, 899, 5555]
> > ```

---

### Метод камня 

> [!question]+ Идея
> Идея аналогичная методу пузырька, только наверх списка **поднимаются максимальные элементы**

> [!example]+ Code
>```python
>A = [2,456,12,467,899,10,5555]
>N = len(A)
>
> for i in range(N):  
>     for j in range(0, N - 1):  
>         if A[j] < A[j + 1]:  
>             A[j], A[j + 1] = A[j + 1], A[j]  
>             
> print(A)
> ```
> > [!abstract]+ Output:
> > ```py
> > [5555, 899, 467, 456, 12, 10, 2]
> > ```

---
### Метод выбора (минимального элемента)

> [!question]+ Идея
> Найти минимальный элемент и поставить его на первое место

>[!code]+
>```python
> A = [2,456,12,467,899,10,5555]
> N = len(A)
>
>for i in range(N-1):
>	nMin = i
>	for j in range(i+1, N):
>		if A[j] < A[nMin]:
>			nMin = j
>	if i != nMin:
>		A[i], A[nMin] = A[nMin], A[i]
>		
> print(A)
>```
> >[!output]+
> >```py
> >[2, 10, 12, 456, 467, 899, 5555]
> >```

---
### Быстрая сортировка

> [!info]+ Идея:
> Выгоднее переставлять элементы, которые находятся дальше друг от друга
> 
> ![[Pasted image 20241216144846.png|center]]
> > [!warning]+ Замечание
> > Для массива из N элементов нужно N / 2 обменов!

> [!example]+ Быстрая сортировка общего вида
> ```py
def qSort (A, nStart, nEnd):  
>     if nStart >= nEnd: return # Выход из функции  
>     L = nStart  
>     R = nEnd  
>     X = A[(L + R)//2]  
>     while L <= R:  
>         # разделители на 2 части  
>         while A[L] < X: L += 1   
> 		while A[R] > X: R -= 1  
>         if L <= R:  
>             A[L], A[R] = A[R], A[L]  
>             L += 1  
>             R -= 1  
>     # рекурсивные вызовы  
>     qSort (A, nStart, R)   
>     qSort (A, L, nEnd)
>     
>     return A
> ```
> **В стиле Python**
> ```py
from random import choice  
> def qSort(A):  
>     if len(A) <= 1: return A  
>     X = choice(A)  
>     B1 = [b for b in A if b < X]  
>     BX = [b for b in A if b == X]  
>     B2 = [b for b in A if b > X]  
>     return qSort(B1) + BX + qSort(B2)
>     
>     return A
> ```

## Двоичный поиск в массиве
**Двоичный поиск значения** в списке или массиве используется только для упорядоченных последовательностей, то есть отсортированных по возрастанию или убыванию.

Для примера на рисунке показан поиск числа X = 44 в отсортированном массиве:

![[qwadx.jpg]]
Серым фоном выделены ячейки, которые уже не рассматриваются, потому что в них не может быть заданного числа. Переменные L и R ограничивают «рабочую зону»

> [!code]+
> ```python
> A = [6, 34, 44, 55, 67, 78, 82] # Массив
> value = 44 # искомое число
> 
> L = 0; R = len(A) # начальный отрезок
> while L < R-1:
> 	c = (L + R) // 2 # нашли середину
> 	if value < A[c]: # сжатие отрезка
> 		R = c
> 	else:
> 		L = c
> if A[L] == value:
> 	print('A[', L, ']=', value, sep ='')
> else:
> 	print('Не нашли!')
> ```
> > [!output]+
> > ```py
> > A[2]=44
> > ```

## Символьные строки
***Строка*** - последовательность символов. Строка - это неизменяемый объект!!
***Подстрока*** - некоторая часть строки, которую нужно найти и извлечь (для определённых функций и операций).

``` py 
s = "Привет!" # - начальное значение
``` 

| 0   | 1   | 2   | 3   | 4   | 5     | 6   |
| --- | --- | --- | --- | --- | ----- | --- |
| П   | Р   | И   | В   | Е   | ==Т== | !   |
| -7  | -6  | -5  | -4  | -3  | -2    | -1  |
Вывод на экран:
```py
print( s ) # ПРИВЕТ
print( s[5] ) # Т
print( s[-2] ) # T
```

==" len( чью длину нужно найти ) "== - функция, которая находит длину строки
### Срезы
```py
s = "0123456789"
s1 = s[3:8] # "34567"
```
Срезает от 3го элемента ***включительно***; до 8го ***не включительно***

![[Pasted image 20241018075028.png]]
==" A[ от чего : до чего : шаг] "== - Срез
> [!info]+ Срезы
> От начала строки
> ```py
> s = "0123456789"
>s1 = s[:8] # "01234567"
>```
>До конца строки
>```py
>s = "0123456789"
s1 = s[3:] # "3456789"
>```
Реверс строки
>```py
s = "0123456789" 
s1 = s[::-1] # "9876543210"
#### Срезы с отрицательными индексами:
> [!info]+ Срезы с отрицательными индексами
> ```py
s = "0123456789"
s1 = s[:-2] # "01234567"
>```
>```py
>s = "0123456789"
s1 = s[-6:-2] # "4567"

## Функции для работы с символьными строками

> [!abstract]+ Операции со строками
> ***Удаление:***
> ```py
> s = "0123456789"
> s1 = s[:3] + s[9:] # "0129"
> ```
>***Вставка:***
>```py
> s = "0123456789"
> s1 = s[:3] + "ABC" + s[9:] # "012ABC3456789"
> ```
> ***Верхний/нижний регистр:***
> ==" A.upper() "== - переводит все ***строчные*** буквы в строке в ***заглавные***
> ==" A.lower() "== - переводит все ***заглавные*** буквы в строке в ***строчные***
>```py
>s = "aAbBcC"
>s1 = s.upper() # "AABBCC"
>s2 = s.lower() # "aabbcc"
>```
>***Проверка на цифры:***
>==" A.isdigit() "== - функция, которая проверяет строку на цифры
>```py
>s = "abc"
>print( s.isdigit() ) # False
>s1 = "123"
>print( s1.isdigit() ) # True
>```
>> [!warning]+ Замечание!
> Если в строке с цифрами будет хотя бы одна буква, то функция принимает значение `False`
### Поиск в строках
==" A.find( элемент в строке ) "== - Находит первое слева вхождение подстроки. Если элемент не найден, то выводит "-1"

```py
s = "Здесь был Вася."  
n = s.find( "с") # n=3  
if n >= 0:  
    print("Номер символа",n)  
else:  
    print("Символ ненайден.")
```

==" A.rfind( элемент в строке ) "== - Находит первое справа вхождение подстроки
```py
s = "Здесь был Вася."
n = s.rfind ( "c" ) # n = 12
```

## Преобразования «строка-число»
## Строки в процедурах и функциях
## Рекурсивный перебор
## Сравнение и сортировка строк
## Обработка массивов, записанных в файле
## Обработка смешанных данных, записанных в файле

---
- [ ] Вложенные циклы
- [x] Рекурсия