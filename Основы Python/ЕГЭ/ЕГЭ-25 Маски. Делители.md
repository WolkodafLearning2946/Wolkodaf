# Поиск делителей

> [!question]+ Problem
> Напишите программу, которая **ищет** среди целых чисел, принадлежащих отрезку [244143; 367821], **числа**, **имеющие ровно 5 различных делителей**. Выведите эти делители для каждого найденного числа в порядке возрастания

>[!code]+
>Сначала напишем программу, которая ищет делители числа
>```py
> x = 12345 # Хотим найти делители от этого числа
>```
>Чтобы это сделать, нужно перебрать все числа **от 1 до этого числа** *(больше этого числа делителей не будет)*
>
>```python
> x = 12345
> c = set() # Создадим множество, для сбора делителей
> for i in range(1, x+1):
> 	if x % i == 0:
> 		c.add(i) # Добавляем делитель в множество
> print(*sorted(c)) # Выводим делители в порядке возрастания без лишних запятых и скобочек
>```
>>[!output]+
>>```py
>>1 3 5 15 823 2469 4115 12345
>>```
>>
>---
>
>Теперь добавим к решению отрезок из задания - **[244143; 367821]**, а также выведем числа у которых только **5 делителей**:
>```py
> for x in range(244143, 367821 + 1):  
>     c = set()  
>     for i in range(1, x+1):  
>         if x % i == 0:  
>             c.add(i)  
>     if len(c) == 5:  
>         print(x, sorted(c)) # Выводим число, а потом множество делителей этого числа
>```
>> [!bug]+ Появилась проблема!
> Если вы запустите этот код в python, то из-за большего промежутка чисел вы заметите, что код работает **очень медленно**
> 
> > [!accept]+ Оптимизация решения
> > > [!example]+ Рассмотрим число, у которых 5 делителей:
> > > **Например число 16:**
> > > ![[Pasted image 20250111102433.png]]
> > > У каждого числа <u>парные</u> делители
> > > > <u>Парный делитель</u> - это значит, что их **произведение = числу**
> > > > 
> > > > $1 \times 16 = 16$
> > > > $2 \times 8 = 16$
> > > > $4 \times 4 = 16$
> > > > 
> > > Число $16$ имеет делитель $4$, у которого не парного делителя, кроме самой $4$. Следовательно, число <u>**16 - полный квадрат**</u>
> > > 
> > > Если же мы рассмотрим другое число, которое не является полным квадратом *(например 8)*
> > > ![[Pasted image 20250111103700.png|550 x 200]]
> > > > [!success]+ Вывод
> > > > Число, которое имеет 5 различных делителей является **полным квадратом**. Согласитесь, в нашем отрезке **[244143; 367821]** **квадратов** во много раз меньше, чем **не квадратов**, поэтому теперь мы не будем перебирать всё подряд, совершая лишние действия
> > 
> > > [!abstract]+ Способ перебора квадратов
> > > **Возьмём число 16 и 12:**
> > > $\sqrt{16} = 4, 0$
> > > $\sqrt{12} \approx 3, 5$
> > > Если число является полным квадратом, то в дробной части будет `0`, в отличии от неполного квадрата, 
> > > поэтому, если мы <mark style="background: #63C251;">откинем дробную часть у полного квадрата</mark> ($4,\cancel0 = 4$), то <mark style="background: #63C251;">ничего не изменится</mark>, а если мы <mark style="background: #FF5582A6;">откинем дробную часть у неполного квадрата</mark> ($3,\cancel5 \neq 3$), то получится <mark style="background: #FF5582A6;">совсем другое число</mark>
> > > **Отсекать дробную часть будем с помощью функции** `int()`
> > > >[!code]+ Изменим код
> > > > ```python
> > > > for x in range(244143, 367821 + 1):  
> > > >     c = set() 
> > > >     
> > > >     if x ** 0.5 == int(x**0.5):  # Новое условие
> > > >     
> > > >         for i in range(1, x+1):  
> > > >             if x % i == 0:  
> > > >                 c.add(i)  
> > > >     if len(c) == 5:  
> > > >         print(x, sorted(c))
> > > > ```
> > 
> > > [!tip]+ Также к оптимизации можем добавить следующее:
> > > ![[Pasted image 20250111140409.png]]
> > > Чтобы проходить быстрее по числам, можем идти только до квадрата и узнавать первые делители, а парные им делители будем находить с помощью деления основного числа на найденный делитель
> > >![[Pasted image 20250111122412.png]]

Зная метод оптимизации, теперь мы можем написать итоговый оптимизированный код:
>[!code]+
>```python
> for x in range(244143, 367821 + 1):  
>     c = set()  
>     if x ** 0.5 == int(x**0.5):  
>         for i in range(1, int(x**0.5)+1):  # Идём до корня
>             if x % i == 0:  
>                 c.add(i)  
>                 c.add(x // i) # Добавляем парный делитель в мн-во
>     if len(c) == 5:  
>         print(x, sorted(c))
>```

---

## Полезные [[Основы Python/7. Процедуры и функции/2. Функции|функции]]

>[!code]- Функция, которая проверяет, является ли число простым
>```py
> def prime(n): #   
>     for i in range(2, int(n**0.5)+1):  
>         if n % i == 0:  
>             return False  
>     return True
>```

>[!code]- Функция, которая возвращает список делителей заданного числа
>```py
> def divs(n):  
>     d = set()  
>     for i in range(1, int(n**0.5)+1):  
>         if n % i == 0:  
>             d.add(i)  
>             d.add(n//i)  
>     return sorted(d)
>```

---

## Задачи для отработки
> [!question]+ Problem
> Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку **[174457; 174505]**, числа, имеющие ровно **два различных натуральных делителя**, *не считая единицы и самого числа*. 
> 
> Для каждого найденного числа **запишите эти два делителя в два соседних столбца** на экране с новой строки в порядке возрастания произведения этих двух делителей. *Делители в строке также должны следовать в порядке возрастания.*
> 
> **Например**, в диапазоне [5; 9] ровно два различных натуральных делителя имеют числа 6 и 8, поэтому для этого диапазона вывод на экране должна содержать следующие значения:
> **2 3**
> **2 4**
> > [!success]- Answer
> > ```py
> > 3 58153
> > 7 24923
> > 59 2957
> > 13 13421
> > 149 1171
> > 5 34897
> > 211 827
> > 2 87251
> > ```
> 
> >[!code]- Solution *(официальное)*
> >```py
> > for x in range(174457,174505+1):
> >     k=0
> >     s=[]
> >     for y in range(2,x//2+1):
> >         if x%y==0:
> >             k+=1
> >             s.append(y)
> >             if k>2:
> >                 break
> >     if k==2:
> >         print(*s)
> >```
> 
> >[!code]- Solution *(моё)*
>>```py
>> import math  
>>   
>> add1 = []  
>> for x in range(174457, 174505 + 1):  
>>     c = set()  
>>     for i in range(2,int(x**0.5)):  
>>         if x % i == 0:  
>>             c.add(i)  
>>             c.add(x // i)  
>>     if len(c) == 2:  
>>         add1.append(sorted(c))  
>> print(sorted(add1, key=lambda x: math.prod(x)))
>>```

> [!question]+ Problem
> Обозначим через F целую часть среднего арифметического всех **простых** делителей целого числа, не считая самого числа. Если таких делителей у числа нет, то считаем значение F равным нулю. 
> Напишите программу, которая перебирает целые числа, большие 650000, в порядке возрастания и ищет среди них такие, для которых значение F при делении на 37 даёт в остатке 23. 
> 
> Выведите первые 4 найденных числа в порядке возрастания и справа от каждого числа – соответствующее значение F.
> >[!success]- Answer
>> ```py
>> 650090 60
>> 650153 282
>> 650155 3945
>> 650208 134
>>```
>
>>[!code]- Solution
>> ```py
>> def prime(n): # функция, которая проверяет, является ли число простым  
>>     for i in range(2, int(n**0.5)+1):  
>>         if n % i == 0:  
>>             return False  
>>     return True  
>> def divs(n):  # функция, которая возвращает список всех делителей числа
>>     d = set()  
>>     for i in range(2, int(n**0.5)): # нужны простые делители (1 - не простое число). само число тоже не нужно => в цикле единицу можем не добавлять
>>         if n % i == 0:  
>>             d.add(i)  
>>             d.add(n//i)  
>>     return sorted(d)  
>>   
>> count = 0  
>> for q in range(650001, 10**6): # случайное конечное значение (если не хватит. то можно добавить)
>>     l = [x for x in divs(q) if prime(x)] # создаём список, который выбирает простые делители
>>     if len(l) > 0:  
>>         f = sum(l) // len(l)  
>>         if f % 37 == 23:  
>>             print(q,f)  
>>             count+=1  
>>             if count == 4:  
>>                 break
>>```

> [!question]+ Problem
> Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [190201; 190260], числа, имеющие ровно 4 различных **чётных** делителя. В ответе для каждого найденного числа запишите два его наибольших **чётных** делителя в порядке убывания.
> > [!success]- Answer
> > ```py
> > 190226 838
> > 190234 17294
> > 190238 2606
> > 190252 95126
> > 190258 758
> > ```
> 
> >[!code]- Solution
> > ```py
> > def divs(n):  
> >     d = set()  
> >     for i in range(1, int(n**0.5)+1):  
> >         if n % i == 0:  # В самой функции ставим условие, чтобы во множество заносились только чётные делители
> >             if i % 2 == 0:  
> >                 d.add(i)  
> >             if (n//i) % 2 == 0:  
> >                 d.add(n//i)  
> >     return sorted(d)  
> >   
> > for j in range(190201, 190260 + 1):  
> >     g = divs(j)  
> >     if len(g) == 4:  
> >         print(max(g), end = ' ')  
> >         g.remove(max(g))  
> >         print(max(g))
> > ```

> [!question]+ Problem
> Напишите программу, которая перебирает целые числа, **большие 800000**, в порядке возрастания и ищет среди них такие, у которых есть **натуральный делитель, оканчивающийся на цифру 9 и не равный ни самому числу, ни числу 9**. 
> В ответе запишите в первом столбце таблицы первые пять найденных чисел в порядке возрастания, а во втором столбце — соответствующий минимальный делитель для каждого числа, оканчивающийся цифрой 9, не равный ни самому числу, ни числу 9. Строки выводятся в порядке возрастания найденных чисел.
> > [!success]- Answer
> > ```py
> > 800001 309
> > 800003 47059
> > 800004 409
> > 800006 269
> > 800007 39
> > ```
> 
> >[!code]- Solution
> >```py
> > def divs(n):  
> >     d = set()  
> >     for i in range(1, int(n**0.5)):  
> >         if n % i == 0:  
> >             d.add(i)  
> >             d.add(n//i)  
> >     return sorted(d)  
> >   
> > count = 0  
> > for i in range(800000, 10**7):  
> >     for j in divs(i):  
> >         if j % 10 == 9 and j != 9:  
> >             print(i,j)  
> >             count += 1  
> >             break  
> >     if count == 5:  
> >         break
> >```

> [!question]+ Problem
> Назовём нетривиальным делителем натурального числа его делитель, не равный единице и самому числу. Например, у числа 6 есть два нетривиальных делителя: 2 и 3. Найдите все натуральные числа, принадлежащие отрезку [123456789; 223456789] и имеющие ровно три нетривиальных делителя. Для каждого найденного числа запишите в ответе его наибольший нетривиальный делитель. Ответы расположите в порядке возрастания. 
> 
> Например, в диапазоне [5; 16] ровно три различных нетривиальных делителя имеет число 16, поэтому для этого диапазона вывод на экране должна содержать следующие значения: 
> 16 8
> >[!success]- Answer
> >```py
> > 131079601 1225043
> > 141158161 1295029
> > 163047361 1442897
> > ```
> 
> >[!code]- Solution
> > ```py
> > def divs(n):  
> >     for i in range(2,int(n**0.5)):  
> >         d = set()  
> >         if i ** 0.5 == int(i ** 0.5):  
> >             if n % i == 0:  
> >                 d.add(i)  
> >                 d.add(n//i)  
> >                 if len(d) > 3:  
> >                     return []  
> >     return sorted(d)  
> >   
> > for i in range(123456789, 223456789 + 1):  
> >     g = divs(i)  
> >     if len(g) == 3:  
> >         print(i, max(g))
> > ```
> 
> >[!code]- Solution (Оптимизация)
> > Перед решением задачи стоит применить **свойство чисел с тремя нетривиальными делителями**:
> > > [!info]+ Definition
> >> **Свойство чисел с тремя нетривиальными делителями:** Число `n` имеет ровно три нетривиальных делителя, если оно представимо как $p^{4}$, где $p$ — простое число. 
> >> **Почему?** Если число $n=p^{4}$, то его делители: $1, p, p^2, p^3, p^4$, и среди них ровно три ( $p, p^2, p^3$) являются нетривиальными.
> >> > [!example]+ Пример
> >> >![[Pasted image 20250112171916.png]]
> >
> > **Итерация по $p^4$:** Вместо перебора всех чисел из диапазона, достаточно искать такие $p$, что $p^4$ попадает в диапазон [123456789;223456789]. Это резко сократит количество проверяемых чисел.
>> ```python
>> def is_prime(n):
>>     """Проверяет, является ли число простым."""
>>     if n < 2:
>>         return False
>>     for i in range(2, int(n**0.5) + 1):
>>         if n % i == 0:
>>             return False
>>     return True
>> 
>> # Границы диапазона
>> low = 123456789
>> high = 223456789
>> 
>> # Список подходящих чисел
>> results = []
>> 
>> # Перебираем все возможные p и вычисляем p^4
>> for p in range(2, int(high**0.25) + 1):  # p^4 ≤ high → p ≤ high**0.25
>>     if is_prime(p):
>>         p4 = p**4
>>         if low <= p4 <= high:
>>             results.append((p4, p**3))  # p^3 — наибольший нетривиальный делитель
>> 
>> # Сортируем и выводим результаты
>> for number, largest_divisor in results:
>>     print(number, largest_divisor)
>>```

> [!question]+ Problem
> ![[Pasted image 20250119185027.png]]
> > [!success]- Answer
> > ```py
> > 1091880 1182870
> > 1116144 1209156
> > 1140408 1235442
> > 1164672 1261728
> > 1188936 1288014
> > ```
> 
> > [!code]- Solution
> >```python
> > def divs(n):  
> >     d = set()  
> >     for i in range(2, int(n**0.5)):  
> >         if n % i == 0:  
> >             d.add(n//i)  
> >     return sorted(d)[-3:]  
> >   
> > def s(n):  
> >     l = divs(n)  
> >     if len(l) >= 3:  
> >         return sum(l)  
> >     return 0  
> >   
> > count = 0  
> > for i in range(1_200_000, 0, -1):  
> >     s1 = s(i)  
> >     if s1 != 0 and s1 != i and s1 % 2022 == 0:  
> >         print(i, s1)  
> >         count += 1  
> >         if count == 5:  
> >             break
> >```
> > > [!output]+
> > >```py
> > > 1188936 1288014
> > > 1164672 1261728
> > > 1140408 1235442
> > > 1116144 1209156
> > > 1091880 1182870
> > >```



 

---
# Маски

> [!question]+ Problem
> Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы: 
> 
> — **символ «?»** означает ровно одну произвольную цифру; 
> — **символ «*»** означает любую последовательность цифр произвольной длины; в том числе «*» может задавать и пустую последовательность. 
> 
> **Например**, маске 123\*4?5 соответствуют числа 123405 и 12300405. 
> 
> Среди натуральных чисел, не превышающих 10<sup>10</sup>, найдите все числа, соответствующие маске **3?12?14\*5**, делящиеся на 1917 без остатка. 
> В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания, а во втором столбце — соответствующие им результаты деления этих чисел на 1917.

>[!code]+
> Подключим библиотеку, которая может проверять, подходит ли число под маску
>```py
> from fnmatch import fnmatch
>```
> **Решение:**
> ```python
> from fnmatch import * 
> for x in range(0, 10**10, 1917): 
> # Перебираем все числа от 0 с шагом 1917, будут получены числа кратные 1917 
> 	if fnmatch(str(x), '3?12?14*5'): 
> 	# Проверяем полученное число соответствию заданию 
> 		print(x, x//1917)
> ```

> [!success]+ Answer
> ```py
> 351261495 183235
> 3212614035 1675855
> 3412614645 1780185
> 3712414275 1936575
> 3912414885 2040905
> ```