# Как решать
> [!question]+ Задача (элементарная, которая на ЕГЭ не попадётся)
> В текстовом файле `k7-84.txt` находится цепочка из символов латинского алфавита A, B, C. Найдите длину самой длинной подцепочки, состоящей из символов С
> > [!tip]+ Совет
> > С самого начала решения стоит не подключать файл, а написать строку, которая поможет проверить код на правильность.

> [!abstract]+ Алгоритм решения:
> 1. Создадим переменную счётчик (m):
> 2. Для подсчёта длины подцепочки мы будем рассматривать пары чисел:
> 	- Если первый символ C и следующий тоже С, то `m +
>    1`
> 	- Иначе `m = 0`
> Тем самым мы можем посчитать максимальную длину подстроки `m`

> [!example]+ Код
> ```py
> s = "​​ABCCCAABCCCCCCABCCABC"
> m = 0
> for i in range(len(s)):
> 	if s[i] == "C":
> 		m += 1
> 	else:
> 		m = 0
> 	print(m, end = " ")
> ```
> > [!abstract]+ Вывод:
> >```py
> >'''
> >Каждый раз, когда C `m + 1`
> >​​A B C C C A A B C C C C C C A B C C A B C
> >'''
> >0 0 1 2 3 0 0 0 1 2 3 4 5 6 0 0 1 2 0 0 1
> >```

Нас интересует максимальное число среди выводимых, поэтому будем выводить максимальное число среди `m`
> [!example]+ Итоговый код решения:
> ```python
> s = "​​ABCCCAABCCCCCCABCCABC"
> m = 0
> maxi = 0
> for i in range(len(s)):
> 	if s[i] == "C":
> 		m += 1
> 		if m > maxi:
> 			maxi = m
> 	else:
> 		m = 0
> print(maxi)
> ```
> > [!abstract]+ Вывод / Ответ
> > ```py
> > 6
> > ```

---
## [[5. Подключение файла для чтения (не простейшая программа)|Подключение файла]]
---

> [!question]+ Задача
> В текстовом файле `k7.txt` находится цепочка из символов, в которую могут входить заглавные буквы латинского алфавита A...Z и десятичные цифры. **Найдите длину самой длинной подцепочки, состоящей из одинаковых символов**. Если в файле несколько цепочек одинаковой длины, нужно взять **первую из них**. Выведите сначала **символ**, из которого строится эта подцепочка, а затем через пробел - **длину этой подцепочки**

> [!tip]+ Алгоритм
>- В этом случае мы будем проверять пары чисел. Если первый символ = второму, то `l += 1`
>- Написанная программа будет считать пары, пар всегда на 1 меньше, чем всего элементы, поэтому в выводе `+=1`

> [!example]+ Код
> ```python
> s = "​​ABCCCAABCCCCCCABCCABC"
> l = maxi = 0
> t = [0]
> for i in range(len(s)-1): 
> # Мы проверяем пары чисел. Если мы будем проверять пары чисел столько раз, сколько символов в строке, то последний символ останется без пары (мы выйдем за границы строки), и из-за этого выведется ошибка. Пар всегда меньше на 1, чем символов, поэтому вычитаем 1
> 	if s[i] == s[i+1]:
> 		l += 1
> 		if l > maxi:
> 			maxi = l
> 			t = s[i]
> 	else:
> 		l = 0
> print(t, maxi + 1) # код считает пары, а не символы => добавляем 1
>```
>> [!abstract]+ Вывод/Ответ
> ```
>C 6 
>```
>Проверили, что программа работает верно, теперь можем подключить файл из задания

> [!warning]+ А что, если нужно будет вывести не первую подцепочку, а последнюю?
> В прошлом коде мы используем строгую проверку:
> ```py
> if l > maxi:
> 	maxi = l
> 	t = s[i]
>```
> Следующая строка будет **равна** длине прошлой подцепочки, поэтому символ и не перезаписывается.
> Чтобы найти символ самой длинной последней подцепочки, нужно поменять строгий знак `>` на нестрогий `>=`

---

> [!question]+ Задача
> Текстовый файл `24-196.txt` содержит строку из заглавных латинских букв X,Y и Z, всего не более чем из $10^6$ символов. Определите максимальное количество идущих подряд пар символов ZX или ZY.
> > [!tip]+ Способ решения
> > Так как мы ищем `ZX` или `ZY`, то можно заменить в строке все `ZY` на `ZX` и ответ не поменяется

> [!example]+ Code
> ```python
> s = 'xxxxZXZXZYxxxZYZXxxxxxxxxxxxZYxxx'
> b = 0
> s = s.replace('ZY', 'ZX')
> for i in range(len(s)):
> 	if 'ZX'*i in s:
> 		b = i
> print(b)
> ```

> [!warning]+ Прямая замена не всегда будет работать для решения задач. Например в следующей задаче:

> [!question]+ Задача
> Текстовый файл `24-224.txt` содержит строку из символов A,B и C, всего не более, чем $10^6$ символов. Найдите максимальную длину строки, состоящей только из комбинаций BAC и CAB. 
> Например, в строке BABABACCABCABCB такая подстрока BACCABCAB (длина 9).

> [!bug]+ Почему нельзя обычной заменой?
> ```py
> s = "BACABCAB"
> # В этой строке BAC и CAB пересекаются и, если мы их заменим, то значения потеряются!!
> ```

> [!example]+ Предлагается заменить `BACAB` => `BAC_CAB`, а `CABAC` => `CAB_BAC`
 > ```python
> s = 'BACABACABACCAB'
> while 'BACAB' in s:
> 	s = s.replace('BACAB', 'BAC_CAB')
> while 'CABAC' in s:
> 	s = s.replace('CABAC', 'CAB_BAC')
> s = s.replace('CAB', '***').replace('BAC', '***') # Заменяем всё на один символ
>#print(s)
># Дальше действуем, как раньше:
>b=0
>for i in range(len(s)):
>	if "*" *i in s:
>		b=i
>print(b)
> ```
> > [!abstract]+ Вывод:
> > ```py
> > 6
> > ```

> [!failure]+ Способ не очень надёжный!!
> В тексте может попасться ситуация, которую вы не учли в коде

---
## Задачи для понимания

> [!question]+ Problem
> Текстовый файл состоит не более чем из 1 200 000 символов X,Y и Z. Определите максимальное количество идущих подряд символов, среди которых нет подстроки XZZY
> > [!code]- Solution
> >```py
> > # with open("k7.txt", "r") as F:  
> > #   s = F.readline().split('XZZY')  
> >   
> > x = 'ZXYZYXYZXYZXZZYXXYYXXZZYXZYXZZYXXXX'  
> > s = x.split('XZZY') # ['ZXYZYXYZXYZ', 'XXYYX', 'XZY', 'XXXX']  
> > maxi = 0  
> >   
> > for i in range(len(s)):  
> >     if len(s[i]) > maxi:  
> >         maxi = len(s[i])  
> > print(3 + maxi + 3) # 'ZZY + максимальная последовательность + XZZ'
> >```

> [!question]+ Problem
> Текстовая строка состоит из символов X,Y и Z. Определите максимальную длину цепочки вида XYZXYZXYZ... (составленной из фрагментов XYZ, **последний фрагмент может быть неполным**)
> >[!code]- Solution
> >![[Pasted image 20241221181639.png]]
> > ```py
> > s = 'XYZXYXYZXYZX'  
> > k = 0  
> > maxi = 0  
> >   
> > for i in range(len(s)):  
> >     if s[i] == 'X' and k % 3 == 0:  
> >         k += 1  
> >         maxi = max(maxi,k)  
> >     elif s[i] == 'Y' and k % 3 == 1:  
> >         k += 1  
> >         maxi = max(maxi,k)  
> >     elif s[i] == 'Z' and k % 3 == 2:  
> >         k += 1  
> >         maxi = max(maxi, k)  
> >     else:  
> >         if s[i] == 'X':  
> >             k = 1  
> >         else:  
> >             k = 0  
> > print(maxi)
> >```

> [!question]+ Problem
> Текстовая строка состоит из символов P, Q и S. Определите максимальное количество идущих подряд символов в строке, среди которых нет идущих подряд символов P
> >[!code]- Solution
> > ```python
> > s = 'PQRSSSPPRRRPPPPSSSPP'
> > k = 1
> > maxi = 1
> > for i in range(1, len(s)):
> > 	if s[i-1] + s[i] == 'PP':
> > 		k = 1
> > 	else:
> > 		k += 1
> > 		maxi = max(maxi,k)
> > print(maxi)
> > ```

> [!question]+ Problem
> Текстовая строка содержит только заглавные буквы латинского алфавита (ABC...Z). Определите максимальное количество идущих подряд символов, среди которых нет ни одной буквы A и при этом не менее трёх букв E.
> >[!code]- Solution
> >```python
> > s1 = 'AFGTREEFGEAFJJHGEEE'  
> > s = s1.split('A')  
> > k = 0  
> > maxi = 0  
> >   
> > for i in range(len(s)):  
> >     if s[i].count('E') == 3:  
> >         k = len(s[i])  
> >         maxi = max(maxi,k)  
> >     else:  
> >         continue  
> >   
> > print(maxi)
> >```

> [!question]+ Problem
> Текстовая строка содержит только заглавные буквы латинского алфавита (ABC...Z). Определите максимальное количество идущих подряд символов, среди которых не более одной буквы D
> >[!code]- Solution
> >```python
> > s1 = 'DSSSDSSSSDSSSSSDSSS'
> > s = s1.split('D')
> > maxi = 0
> > 
> > for i in range(1, len(s)):
> > 	if len(s[i-1] + s[i]) + 1 > maxi:
> > 		maxi = len(s[i-1] + s[i]) + 1
> > print(maxi)
> > 
> >```

---

## Задачи для отработки
> [!question]+ Problem
> В текстовом файле `k7.txt` находится цепочка из символов латинского алфавита A, B, C, D, E. Найдите длину самой длинной подцепочки, состоящей из символов A, B или C (в произвольном порядке).
>> [!code]- Solution
> >```py
> >with open("k7.txt", "r") as F:
> >	s = F.readline()
> >count = maxCount = 0
> >for char in s:
> >	if char in 'ABC':
> >		count += 1
> >		maxCount = max(count, maxCount)
> >	else:
> >		count = 0
> >print(maxCount)
> >```

> [!question]+ Problem
> В текстовом файле `k7.txt` находится цепочка из символов латинского алфавита A, B, C, D, E. Найдите максимальную длину цепочки вида EABEABEABE... (составленной из фрагментов EAB, **последний фрагмент может быть неполным**).
>> [!code]- Solution
> >```py
> > with  open( "k7.txt", "r" ) as F: 
> > 	s = F.readline() 
> > k = '' 
> > while k in s: 
> > 	k += 'E' 
> > 	if k in s: 
> > 		k += 'A' 
> > 		if k in s: 
> > 			k += 'B' 
> > print ( len (k) - 1 )
> >```
> >> [!tip]- Ответ на вопрос "Зачем вычитать единичку в выводе?"
> >> Допустим, возьмём строку `'EABEABEABBBEABEABEAB'`. В этой строке длина подстроки, которая получается из `EAB` = 9, но код (без вычитания единицы) будет выводить 10. Почему?
> >> 
> >> ![[1206.mp4]]
> >> 
> >> ***Мы проходимся по коду в видеоролике***
> >> Дело в том, что код проверяет, есть ли подстрока, которая записана в переменной `k` во всей строке.
> >> 
> >>Подстрока `EABEABEAB` есть в строке, поэтому, по алгоритму добавляет на конец подстроки символ `E`, которого в самой строке нет (этот символ нам не нужен). После чего программа прекращается (цикл while выполнил своё дело).
> >>	
> >>На экран выводиться `len('EABEABEABE')` = `10`. В полученном результате нам нельзя учитывать тот самый символ `E` в конце подстроки, поэтому этот символ из результата и вычитаем

> [!question]+ Problem
> Текстовый файл содержит только буквы _A_, _C_, _D_, _F_, _O_. Определите максимальное количество идущих подряд групп символов вида:
>$$гласная + гласная + согласная$$
>![[task1 1.txt]]
>> [!success]- Answer
>> 4
>
>>[!code]- Solution
>>```py
>> with open('task1.txt', 'r') as F:  
>>     s = F.readline()  
>> k = []  
>> maxi = 0  
>> i = 0  
>> while i < len(s)-2:  
>>     if s[i] in 'AO' and s[i+1] in 'AO' and s[i+2] in 'CDF':  
>>         k+=1  
>>         maxi = max(k,maxi)  
>>         i += 3  
>>     else:  
>>         k = 0  
>>         i += 1  
>> print(maxi)
>>```

> [!question]+ Problem
> ![[Pasted image 20250110183953.png]]
> ![[z12.txt]]
> > [!success]- Answer
> > 85
> 
> >[!code]- Solution
> >```py
> > with open('z12.txt', 'r') as f:  
> >     s = f.readline()  
> >   
> > s = s.replace('2','1').replace('3','1').replace('4','1').replace('5', '1').replace('6','1')  
> > s = s.replace('*','-').replace('B',' ').replace('C', ' ').replace('D', ' ')  
> > s = s.replace('1A', '1 A').replace('--','- -').replace('AA', 'A A').replace('-A', '- A').replace('A-', 'A -')  
> > s = sorted(s.split(), key = len, reverse = 1)  
> >   
> > for i in s:  
> >     if i[-1] == '-':  
> >         i = i[:-1]  
> >     if i[0] == 'A' and i.count('A') == 1:  
> >         print(len(i))  
> >         break
> >```

> [!question]+ Problem
> ![[Pasted image 20250120133602.png]]
> ![[task24.txt]]
> >[!success]- Answer
> > ```py
> > 3126411524055
> > ```
> 
> >[!code]- Solution
> >![[Pasted image 20250120141352.png]]
> >```py
> > with open('task24.txt', 'r') as F:
> >     s = F.readline()
> > # s = 'D021AB320'
> > k = r = 0
> > 
> > for x in s:
> >     if x in '012':
> >         if x != '0':
> >             k += 1
> >         r += k
> >     else:
> >         k = 0
> > print(r)
> >```