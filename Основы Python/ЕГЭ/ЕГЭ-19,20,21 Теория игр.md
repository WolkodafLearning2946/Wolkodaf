# Как решать
> [!todo]  Задание 19
> > [!question]+ Задача
>> Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат **две кучи камней**. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может **добавить в одну из куч один камень** или **увеличить количество камней в куче в два раза**. 
>> Игра завершается в тот момент, когда суммарное количество камней в кучах становится **не менее 63**. 
>> Победителем считается игрок, сделавший последний ход, т.е. первым получивший такую позицию, при которой в кучах будет 63 или больше камней.
>> В начальный момент в первой куче было 5 камней, во второй куче – S камней; 1 ≤ S ≤ 57. 
**Известно, что Ваня выиграл своим первым ходом после неудачного  хода Пети. Укажите минимальное значение S, когда такая ситуация возможна.**


Перед решение задач, нужно отметить, что **чётный ход** - ход Пети, а **нечётный ход** - ход Вани:

![[Pasted image 20241204102146.png]]

> [!tip]+ Совет
> Чтобы лучше погрузиться в задачу, нужно писать код от лица человека из условия

> [!example]+ Создаём [[1.|рекурсивную функцию]]
> ```python
> def f( x, y, h ): # x - первая куча, y = вторая куча, h - номер хода
> 	# Пропишем базовый случай
> 	if x+y >= 63 and h==3: # Если в кучах суммарно >= 63 и ход - первый ход Вани, то ПОБЕДА
> 		return True
> 	else:
> 		if x+y < 63 and h==3: # Если в кучах меньше 63 камней и ход - первый ход Вани, то ПРОИГРЫШ
> 			return False
> 	return f(x+1,y,h+1) or f(x*2,y,h+1) or f(x,y+1,h+1) or f(x,y*2,h+1)
> 	
>'''
>Далее перебираем в цикле все варианты, при начальных условиях. Если будет истина, то выводим `s` и выходим из цикла.
>'''
>
>for s in range(1,57):
>	if f(5,s,1) == True:
>		print(s)
>		break # Нужно найти минимальное значение, поэтому выключаем программу, после первого найденного числа
>```
>> [!success]- Ответ
> 15

---
> [!todo]  Задание 20
> > [!question]+ Задача
> > **...Условие...**
> > Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются **два условия:** 
> > −Петя не может выиграть за один ход; 
> > −Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня. Найденные значения запишите в ответе в порядке возрастания.

> [!tip]+ Изменения в коде:
> За основу берем предыдущий код. 
> Меняем  `h=4`. 
> Если победы нет у Пети, её не должно быть у Вани. Добавляем ограничение. 
> Перебор в основной программе остается прежний, убираем прерывание цикла, так как нужны все значения `s`

> [!example]+ Решение
> ```python
> def f(x,y,h):
> 	if x+y>=63 and h==4:
> 		return True
> 	else:
> 		if x+y<63 and h==4:
> 			return False
> 		else: 
> 		# Если не победил Петя, у Вани победной комбинации быть не должно
> 			if x+y >= 63:
> 				return False
> 	if h%2 ==1: # Если был ход Пети, то будет ход Вани
> 		return f(x+1,y,h+1) or f(x*2,y,h+1) or f(x,y+1,h+1) or f(x,y*2,h+1) 
> 	else: # Если же всё-таки был ход Вани, то будет ход Пети
> 		return f(x+1,y,h+1) and f(x*2,y,h+1) and f(x,y+1,h+1) and f(x,y*2,h+1)
> 
>
>for s in range(1,57):
>	if f(5,s,1) == True:
>		print(s)
>```
>> [!tip]+ Этапы. Список ходов (`or` и `and`)
>> 1. Игрок из условия всегда будет ходить через `or`
>>
>> ```py
>> return f(x+1,y,h+1) or f(x*2,y,h+1) or f(x,y+1,h) or f(x,y*2,h+1)
>> ```
>> 2. Противник почти всегда хочет победить, значит `and`
>>
Игрок ищет **ХОТЯ БЫ ОДИН** выигрышный ход на  **ВСЕ** ходы противника
>> ```py
>> return f(x+1,y,h+1) and f(x*2,y,h+1) and f(x,y+1,h) and f(x,y*2,h+1)
>> ```
>> 3. Если противник сыграл неудачно, то `or`
>>
>>Игрок ищет **ХОТЯ БЫ ОДИН** выигрышный ход на **ЛЮБОЙ** ход противника
>>```py
>>return f(x+1,y,h+1) or f(x*2,y,h+1) or f(x,y+1,h) or f(x,y*2,h+1)
>>```
>>> [!success]- Ответ
>>> 26 и 28

---

> [!todo]  Задача 21
> > [!question]+ Задача
> > **...Условие...**
> > Найдите минимальное значение S, при котором одновременно выполняются два условия:
> > 
> > – у Вани есть выигрышная стратегия, позволяющая ему **выиграть первым или вторым ходом при любой игре Пети**;
> > 
> > – у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом. 
> > > [!quote]+ Комментарий
> >> С самого начала может показаться, что условия противоречат друг другу, но главная суть в том, что Ваня **МОЖЕТ** выиграть при своём первом ходу, но на втором ходу он должен **В ЛЮБОМ СЛУЧАЕ** выиграть

> [!tip]+ Изменения в коде:
> За основу берем предыдущий код. 
> 
> Меняем  `h=5` или `h=3`, так как победа возможна на 3 ходе. 
> 
> Ход теперь нужен **чётный**. Но нужно исключить победы **ТОЛЬКО** на 3 ходу. Добавляем новую функцию, копируя предыдущую. Меняем `h=3`. Остальное не меняем. 
> 
> В основной программе выводим результаты обеих функций и **“в ручную”** исключаем варианты

> [!example]+ Решение
> ```python
> '''
> Первая функция по 5 или 3 ходу:
> '''
> def f(x,y,h):
> 	if x+y >= 63 and (h==5 or h==3): # 3ий или 5ый ход
> 		return True
> 	else:
> 		if x+y < 63 and h==5: 
> 		# Если на 5ом ходу не набралось 63 камня, то ПРОИГРЫШ
> 			return False
> 		else:
> 			if x+y >= 63:
> 				return False
> 	if h%2 == 0:
> 		return f(x+1,y,h+1) or f(x*2,y,h+1) or f(x,y+1,h+1) or f(x,y*2,h+1) 
> 	else:
> 		return f(x+1,y,h+1) and f(x*2,y,h+1) and f(x,y+1,h+1) and f(x,y*2,h+1)
> '''		
>Вторая функция по 3 ходу
>'''
> def f1(x,y,h):
> 	if x+y >= 63 and h==3: # Только 3ий ход
> 		return True
> 	else:
> 		if x+y < 63 and h==3:
> 		# Если на 3ем ходу не набралось 63 камня, то ПРОИГРЫШ
> 			return False
> 		else:
> 			if x+y >= 63:
> 				return False
> 	if h%2 == 0:
> 		return f1(x+1,y,h+1) or f1(x*2,y,h+1) or f1(x,y+1,h+1) or f1(x,y*2,h+1) 
> 	else:
> 		return f1(x+1,y,h+1) and f1(x*2,y,h+1) and f1(x,y+1,h+1) and f1(x,y*2,h+1)
> 
>
>for s in range(1,57):
>	if f(5,s,1) == True: # Действие, когда 3ий или 5ый ход
>		print(s)
>print("<+=========+>")
>for s in range(1,57):
>	if f1(5,s,1) == True: # Действие, когда только 3ий ход
>		print(s)
> ```
> > [!abstract]+ Вывод:
> > ```py
> > 25
> > 27
> > <+=========+>
> > ```

> [!info]+ Уточнение
> В данной задаче чистой победы в 3 ходу нет. Поэтому нам подходят все варианты по первой функции. **Поэтому ответ:**
> > [!success]+ Ответ
> > 25 и 27
>
> Изменим немного условие и получим другой ответ. Тут есть победы только по 3 ходу. **Они, по условию, не подходят, их исключаем**:
> 
> > [!abstract]+ Вывод
> > ```py
> > 50
> > 52
> > 54
> > 56
> > <+=========+>
> > 52
> > 56
> > ```
>
>Отсюда следует **ответ:**
>> [!success]+ Ответ
>>50 и 54

# Оптимизация
> [!bug]+ Замечание!!
> Разобранный код получается **слишком громоздким**. Не правда-ли?
> **Его необходимо оптимизировать:**

> [!tip]+ Этапы. Список ходов (`any` и `all`)
> ==any== = `or`. Используется только в списках
>  ==all== = `and`. Используется только в списках
>  
> 1. Игрок из условия всегда будет ходить через функцию `any`
>
> ```py
> return any( [ f(x+1, h+1), f(x*2, h+1) ] )
> ```
> 2. Противник почти всегда хочет победить, значит через функцию `all`
>
Игрок ищет **ХОТЯ БЫ ОДИН** выигрышный ход на  **ВСЕ** ходы противника
> ```py
> return all( [ f(x+1,y,h+1), f(x+3,y,h+1), f(x*2,y,h+1) ] )
> ```
> 3. Если противник сыграл неудачно, то у него `any`
>
>Игрок ищет **ХОТЯ БЫ ОДИН** выигрышный ход на **ЛЮБОЙ** ход противника
>```py
>return any( [ f(x+1,y,h+1), f(x+3,y,h+1), f(x*2,y,h+1) ] )
>```

> [!todo]+  Задача 19
> > [!question]+ Напоминание
> > Известно, что Ваня выиграл своим первым ходом после **неудачного** хода Пети. Укажите **минимальное значение** S, когда такая ситуация возможна.

> [!example]+ Оптимизированное решение на примере предыдущей задачи:
> ```python
> def f(a,b,n):
> 	# Проверяем условие, что кто-то победил. Дальше первого Вани не идём, ведь это не нужно по условию
> 	if a + b >= 63 or n > 3:
> 		return n == 3
> 	'''
> 	Добавляем ходы. По условию, противник сыграл неудачно, поэтому найдётся один СЛУЧАЙ, когда Ваня победил => все будут ходить через `any`
> 	'''
> 	h = [f(a+1, b, n+1), f(a*2,b,n+1), f(a,b+1,n+1), f(a,b*2,n+1)]
> 	return any(h)
>
> print(min([s for s in range (1,57+1) if f(5,s,1)])) # Ищем минимальную позицию по условию
> ```
> > [!success]+ Ответ
> > 15
> > **Такой же, как и раньше*

---
> [!todo]  Задание 20
> > [!question]+ Напоминание
> > **...Условие...**
> > Найдите два таких значения S, при которых у Пети есть **выигрышная стратегия**, причём одновременно выполняются два условия: 
> > − Петя не может выиграть за один ход; 
> > − Петя может выиграть своим **вторым ходом независимо от того, как будет ходить Ваня.** Найденные значения запишите в ответе в порядке возрастания.

> [!example]+ Оптимизированный код
> ```python
> def f(a,b,n):
> 	# 4 ход - второй ход Пети
> 	if a + b >= 63 or n > 4: return n == 4
> 	h = [f(a+1, b, n+1), f(a*2,b,n+1), f(a,b+1,n+1), f(a,b*2,n+1)]
> 	# Добавился противник
> 	return all(h) if n % 2 == 0 else any(h) # Если был ход Пети, то будет ход Вани и наоборот
> 	
> print([s for s in range (1,57+1) if f(5,s,1)])
> ``` 
> > [!abstract]+ Вывод / Ответ
> > ```py
> > [26, 28]
> > ```

---

> [!todo]  Задание 21
> > [!question]+ Напоминание
> >**...Условие...**  
>>Найдите минимальное значение S, при котором одновременно выполняются два условия:
>>
>>– **у Вани есть выигрышная стратегия**, позволяющая ему выиграть первым или вторым ходом **при любой игре Пети**;
>>
>>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

> [!example]+ Оптимизированный код
> ```python
> # Создаём функцию для 3го или 5го хода
> def f(a,b,n):
>	if a + b >= 63 or n > 5 : return n == 5 or n == 3
>	h = [f(a+1, b, n+1), f(a*2,b,n+1), f(a,b+1,n+1), f(a,b*2,n+1)]
>	return all(h) if n % 2 != 0 else any(h)
>
># "Создаём" функцию, которая будет для 3го хода
>def f1(a,b,n):
>	if a + b >= 63 or n > 3 : return n == 5 or n == 3
>	h = [f1(a+1, b, n+1), f1(a*2,b,n+1), f1(a,b+1,n+1), f1(a,b*2,n+1)]
>	return all(h) if n % 2 != 0 else any(h)
>
>print([s for s in range (1,57+1) if f(5,s,1)])
>print('<+===========+>')
>print([s for s in range (1,57+1) if f1(5,s,1)])
> ``` 
> > [!abstract]+ Вывод:
> > ```py
> >  [25, 27]
> >  <+===========+>
> >  []
> >  ```
> >  Исключаем те значения, которые для для первого хода Вани
> 
> > [!success]+ Ответ
> > 25 и 27

# Задачи для отработки
> [!example]- Шаблон
> ```python
> def fun(f, s, p):
>     if f + s >= 86: return p % 2 == 0
>     if p == 0: return 0
> 
>     lst = [fun(f+1, s, p-1), fun(f*2, s, p-1), fun(f, s + 1, p-1), fun(f, s * 2, p-1)]
>     return any(lst) if p % 2 == 1 else all(lst)
> 
> for s in range(1, 72):
>     if fun(14, s, 4) and not fun(14, s, 2):
>         print(s)
> 
> ```

## Сборка №1 (1 куча)

> [!question]+ Problem 19
> Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. Игроки ходят по очереди, первый ход делает Петя. **За один ход игрок может добавить в кучу один или два камня или увеличить количество камней в куче в три раза**. Например, имея кучу из 15 камней, за один ход можно получить кучу из 16, 17 или 45 камней. У каждого игрока, чтобы делать ходы, есть неограниченное количество камней. **Игра завершается в тот момент, когда количество камней в куче становится не менее 74**. Победителем считается игрок, сделавший последний ход, то есть первым получивший кучу, в которой будет 74 или больше камней. В начальный момент в куче было _S_ камней, 1 ≤ S ≤ 73.
> 
> Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника. Описать стратегию игрока  — значит, описать, какой ход он должен сделать в любой ситуации, которая ему может встретиться при различной игре противника.
> 
> Известно, что **Ваня выиграл своим первым ходом после неудачного первого хода Пети**. Укажите минимальное значение _S_, когда такая ситуация возможна.
> > [!success]- Answer
> > 9
>
> > [!example]- Solution
> > ```python
> > def fun(s, p):  
> >     if s >= 74: return p % 2 == 0  
> >     if p == 0: return 0  
> >   
> >     lst = [fun(s+1, p-1), fun(s+2, p-1), fun(s*3, p-1)]  
> >     return any(lst) # Играем без противника. Петя сходил неудачно
> >   
> > for s in range(1, 73+1):  
> >     if fun(s, 2): # 2 ход - первый ход Вани
> >         print(s)  
> >         break
> > ```
> >

> [!question]+ Problem 20
> **...Условие...**
> Найдите три таких значения _S_, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
> *—  Петя не может выиграть за один ход;*
> *—  Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.*
> Найденные значения запишите в ответе в порядке возрастания без разделительных знаков.
> > [!success]- Answer
> > 82223
> 
> > [!example]- Solution 
> > ```python
> > def fun(s, p):  
> >     if s >= 74: return p % 2 == 0  
> >     if p == 0: return 0  
> >   
> >     lst = [fun(s+1, p-1), fun(s+2, p-1), fun(s*3, p-1)]  
> >     return any(lst) if p % 2 != 0 else all(lst)  
> >   
> > print(*[ s for s in range (1, 73 + 1) if not fun (s,1) and fun (s,3)])
> > ```

> [!question]+ Problem 21
> Найдите **минимальное** значение _S_, при котором одновременно выполняются два условия:
> *—  у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом* **при любой игре Пети;**
> 
> *—  у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.*
> > [!success]- Answer
> > 21
>
>> [!example]- Solution
>> ```python
>> def fun(s, p):  
>>     if s >= 74: return p % 2 == 0  
>>     if p == 0: return 0  
>>     lst = [fun(s+1, p-1), fun(s+2, p-1), fun(s*3, p-1)]  
>>     return any(lst) if p % 2 != 0 else all(lst)  
>>   
>> print([s for s in range(1,73+1) if fun(s,2) or fun(s,4)])  
>> print('------------------')  
>> print([s for s in range(1,73+1) if fun(s,2)])
>> ```

---
## Сборка №2 (2 кучи)

> [!question]+ Problem 19
> Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может
> 
> - **добавить в одну из куч один камень** или
> - **увеличить количество камней в куче в два раза**.
> 
> Например, пусть в одной куче 6 камней, а в другой  — 9 камней; такую позицию мы будем обозначать (6, 9). За один ход из позиции (6, 9) можно получить любую из четырёх позиций: (7, 9), (12, 9), (6, 10), (6, 18). Чтобы делать ходы, у каждого игрока есть неограниченное количество камней.
> 
> Игра завершается в тот момент, когда **суммарное количество камней в кучах становится не менее 50.** Победителем считается игрок, сделавший последний ход, то есть первым получивший позицию, в которой в кучах будет 50 или больше камней.
> 
> **В начальный момент в первой куче было 8 камней, во второй куче  — _S_ камней, 1 ≤ _S_ ≤ 41.**
> 
> Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника. Описать стратегию игрока  — значит, описать, какой ход он должен сделать в любой ситуации, которая ему может встретиться при различной игре противника. В описание выигрышной стратегии не следует включать ходы играющего по ней игрока, которые не являются для него безусловно выигрышными, то есть не гарантируют выигрыш независимо от игры противника.
> 
> **Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Укажите минимальное значение _S_, когда такая ситуация возможна.**
> > [!success]- Answer
> > ```py
> > 11
> > ```
> 
> >[!code]- Solution
> >```python
> > def fun(s1, s2, h):  
> >     if s1 + s2 >= 50: return h % 2 == 0  
> >     if h == 0: return 0  
> >     lst = [fun(s1 + 1, s2, h - 1), fun(s1 * 2, s2, h - 1), fun(s1, s2 + 1, h - 1), fun(s1, s2 * 2, h - 1)]  
> >     return any(lst)  
> >   
> > for s in range(1, 41 + 1):  
> >     if fun(8, s, 2):  
> >         print(s)  
> >         break
> >```

> [!question]+ Problem 20
> *...Условие*
> Найдите **два** таких значения _S_, при которых у Пети есть выигрышная стратегия, причём одновременно **выполняются два условия**:
> 
>- Петя не может выиграть за один ход;
>- Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
>
> Найденные значения запишите в ответе в порядке возрастания без разделительных знаков.
> > [!success]- Answer
> > ```py
> > 16 20
> > ```
> 
> >[!code]- Solution
> >```python
> > def fun(s1, s2, h):  
> >     if s1 + s2 >= 50: return h % 2 == 0  
> >     if h == 0: return 0  
> >     lst = [fun(s1 + 1, s2, h - 1), fun(s1 * 2, s2, h - 1), fun(s1, s2 + 1, h - 1), fun(s1, s2 * 2, h - 1)]  
> >     return any(lst) if (h - 1) % 2 == 0 else all(lst)  
> >   
> > print(*[s for s in range(1, 41 + 1) if not fun(8, s, 1) and fun(8, s, 3)])
> >``` 

> [!question]+ Problem 21
> *...Условие*
> Найдите **минимальное** значение _S_, при котором одновременно выполняются два условия:
> 
> - у Вани есть выигрышная стратегия, позволяющая ему выиграть **первым или вторым ходом при любой игре Пети**;
> 
> - у Вани **нет стратегии**, которая позволит ему гарантированно **выиграть первым ходом**.
>
> > [!success]- Answer
> > ```py
> > 19
> > ```
> 
> >[!code]- Solution
> >```py
> > def fun(s1, s2, h):  
> >     if s1 + s2 >= 50: return h % 2 == 0  
> >     if h == 0: return 0  
> >     lst = [fun(s1 + 1, s2, h - 1), fun(s1 * 2, s2, h - 1), fun(s1, s2 + 1, h - 1), fun(s1, s2 * 2, h - 1)]  
> >     return any(lst) if (h - 1) % 2 == 0 else all(lst)  
> >   
> > print(*[s for s in range(1, 41 + 1) if fun(8, s, 2) or fun(8, s, 4)])  
> > print('-' * 10)  
> > print(*[s for s in range(1, 41 + 1) if fun(8, s, 2)])
> >```