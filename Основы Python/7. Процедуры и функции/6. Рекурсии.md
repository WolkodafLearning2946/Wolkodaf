> [!info]+ Definition
> **Рекурсия** - функция, которая в процессе выполнения вызывает саму себя на основе заданных простых базовых случаев
> > [!quote]+ Индуктивное определение
> > - 1 - натуральное число (база индукции)
> > - если $n$ - натуральное, то $n + 1$ - натуральное число

> [!example]+ 
> Числа Фибоначчи:
> $F_{1} = F_{2} = 1$
> $F_{n} = F_{n-1} + F_{n-2}$ , при $n > 2$
> $$1, 1, 2, 3, 5, 8, 13, 21, 34 ...$$
> ---
> Факториал:
> $0! = 1$
> $n! = 1 * 2 * ... * n$ , при $n > 0$ 
> $<=>$
> $n! = (1*2 * ... * (n-1)) * n = (n-1)! * n$

---
## Рекурсивные функции
> [!example]+ Числа Фибоначчи
> ```python
> def fib(n):
> 	if n in (0,1): # Базовый случай
> 		return 1
> 	return fib(n-1) + fib(n-2) # Рекурсия
>
>print(fib(4))
> ```
> > [!abstract]+ Output
> >```py
> > 5
> >```

> [!example]+ Факториал
> ```python
> def fact(n):
> 	if n == 0: # Базовый случай
> 		return 1
> 	return fact(n-1) * n # Рекурсия
>
>print(fact(5))
> ```
> > [!abstract]+ Output
> >```py
> > 120
> >```

---
# Проблема рекурсий
Несмотря на то, что рекурсии более удобны, чем обычные функции и процедуры, **рекурсия будет выполняться больше по времени**. В чём причина?

<u>Проблема рекурсии</u>: внутри неё происходит два вызова самой себя для каждого значения. И так до тех пор, пока не дойдёт до начальных значений аргументов (1,1). В итоге появляется несколько рекурсивных веток:

![[Pasted image 20241220121351.png]]
Числа на схеме показывают номер числа Фибоначчи. Цветом показаны числа с одинаковым номером. Рекурсивная реализация функции выполняет много одинаковых вычислений

> [!info]+ Definition
><u>**Кеширование данных** (мемоизация)</u> - оптимизация процесса загрузки и обработки данных. **Это процесс хранения результатов выполнения функций** и запросов во временном хранилище (кэше) с целью ускорения повторного обращения к ним.
>
>---
>Вместо того чтобы заново выполнять те же операции, можно просто получить результат из кэша, что существенно экономит время и ресурсы.

> [!example]+ 
> Напишем рекурсивную функцию с кешированием, использовав для сохранения вычисленных значений [[2. Словари|словарь]], в котором ключами будут номера чисел последовательности, а значениями — сами числа.
> ```python
> def fib(n): 
> 	if n not in cash: 
> 		cash[n] = fib(n - 1) + fib(n - 2) 
> 	return cash[n]
> 	
> cash = {0: 1, 1: 1}
> ```
> За счёт кеширования количество вызовов рекурсивной функции существенно сократилось

---
## Глубина рекурсии
В Python по умолчанию максимальный размер глубины рекурсии равен 1000, поэтому, к примеру, если нам потребуется найти число Фибоначчи $>1000$, то выведется ошибка:
> [!example]+ 
> ```python
>def fib(n): 
>	if n not in cash: 
>		cash[n] = fib(n - 1) + fib(n - 2) 
>	return cash[n] 
>	
>cash = {0: 1, 1: 1}
>print(fib(2000))
> ```
> > [!abstract]+ Output
> >```python
> > RecursionError: maximum recursion depth exceeded
> >```

Чтобы изменить глубину рекурсии, нужно вызвать функцию `setrecursionlimit()` из стандартного модуля `sys` и передать новое значение для предела глубины
> [!example]+ 
> ```python
> from sys import setrecursionlimit 
> def fib(n): 
> 	if n not in cash: 
> 		cash[n] = fib(n - 1) + fib(n - 2) 
> 	return cash[n] 
> 	
> setrecursionlimit(3000) 
> cash = {0: 1, 1: 1}
> print(fib(2000))
> ```

> [!danger]+ 
> Максимально возможное значение глубины рекурсии **зависит от операционной системы**. Поэтому бесконечно его увеличивать не получится

---
## Ханойские башни
![[Pasted image 20241220113241.png]]
- За один раз переносится один диск
- Класть только меньший диск на больший
- Третий стержень вспомогательный
