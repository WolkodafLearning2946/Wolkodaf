> [!example]+ Напишем функцию, которая для стоимости товара считает окончательную стоимость с учётом скидки в процентах:
> ```python
> def final_price(price, discount):
> 	return price - price * discount / 100   
> 
> print(final_price(1000, 5))
> ```
> > [!abstract]+ Output
>> ```py
>> 950.0
>> ```

> [!info]+ В Python есть возможность задать для аргументов <u>значение по умолчанию</u>
> Если значение для такого аргумента при вызове функции не передаётся, то используется значение по умолчанию
> > [!example]+ Code
>> ```python
>> # Пусть в нашей функции будет скидка по умолчанию 1%
>> def final_price(price, discount = 1): 
>> 	return price - price * discount / 100
>> 	
>> print(final_price(1000, 5)) # Значение скидки не задано, используется значение по умолчанию 
>> print(final_price(1000))
>> ```
>> > [!abstract]+ Output
>>> ```py
>>> 950.0
>>> 990.0
>>> ```

Значение по умолчанию задаётся один раз при объявлении функции. При последующих вызовах оно не меняется. Это может приводить к неожиданным результатам при использовании значений изменяемых типов данных:

> [!warning]+
> ```python
> def add_value(x, list_arg=[]):     
> 	list_arg += [x]     
> 	return list_arg 
> 	 
> print(add_value(0)) 	
> print(add_value(0, [1, 2, 3])) 
> print(add_value(1))
> ```
> > [!abstract]+ Output
> > ```py
> > [0]
> > [1, 2, 3, 0]
> > [0, 1]
> > ```

В программе при объявлении функции создано значение по умолчанию в виде пустого списка. В третьем вызове к значению по умолчанию, <u>в котором уже есть значение 0</u> после первого вызова функции, <u>добавилось значение 1</u>

***Если необходимо*** каждый раз при вызове функции для аргумента задавать значение по умолчанию с изменяемым типом данных, то можно использовать следующий подход: 
> [!success]+ 
> ```python
> def add_value(x, list_arg=None): 
> 	if list_arg is None: 
> 		list_arg = [] 
> 	list_arg += [x] 
> 	return list_arg
> 	
> print(add_value(0)) 
> print(add_value(0, [1, 2, 3])) 
> print(add_value(1))
> ```
> > [!abstract]+ Output
>> ```py
>> [0]
>> [1, 2, 3, 0]
>> [1]
>> ```

При каждом вызове в функции сравнивается значение этого аргумента с `None`, и если это условие выполняется, то в аргумент записывается пустой список

---
> [!info]+ Аргументы
> - Позиционные ( `f(a,b) - f(5,4)` )
> - Именованные (обращение по имени)

В Python есть возможность передать значение аргумента по его имени. В таком случае аргумент **становится уже не позиционным, а именованным**. Именованному аргументу присваивается значение при вызове функции. 

> [!example]+ Используем именованные аргументы в нашей функции из примера про скидки:
> ```python
> def final_price(price, discount=1):     
> 	return price - price * discount / 100 
> 	  
> print(final_price(1000, discount=5)) 
> print(final_price(discount=10, price=1000))
> ```
> **Позиционные** аргументы можно передавать только в порядке использования в функции
> 
> **Именованные** аргументы передаются, как пара «имя=значение», поэтому их можно передавать в любом порядке 
> > [!example]+ 
> > ```py
> > def print_params(a=1, b=2, c=None, d=4): 
> > 	print(a, b, c, d) 
> > 	
> > # Нужно передать только d, но приходится передавать все 
> > print_params(1, 2, 3, 8) 
> > 
> > # Именованные аргументы позволяют передавать только d 
> > # Для остальных аргументов используются значения по умолчанию 
> > print_params(d=8)
> >```
> Именованные аргументы можно передавать одновременно с позиционными. **Тогда позиционные должны идти в самом начале**

Чтобы указать, что функция может принимать неограниченное количество позиционных аргументов, нужно при её объявлении поставить аргумент с <mark style="background-color:#580297">" * "</mark>
> [!example]+ Code
> ```python
> def final_price(*prices, discount=1):     
> 	return [price - price * discount / 100 for price in prices]   
> 
> print(final_price(100, 200, 300, discount=5))
> ```
> > [!abstract]+ Output
> >```py
> > [95.0, 190.0, 285.0]
> >```

Чтобы функция могла принимать неограниченное количество именованных аргументов, нужно при её объявлении поставить аргумент с  <mark style="background-color:#580297">" ** "</mark>
> [!example]+ Code
> ```python
> def final_price(*prices, discount=1, **kwargs):
> # Создаётся словарь. В нём мы записываем значение в переменные: либо заданные в именованных функциях (если есть), либо min/max d в prices при вызове функции
> 	
> 	low = kwargs.get("price_low", min(prices)) 
> 	high = kwargs.get("price_high", max(prices)) 
> 	return [price - price * discount / 100 for price in prices if low <= price <= high] 
> 
> print(final_price(100, 200, 300, 400, 500, discount=5)) 
> print(final_price(100, 200, 300, 400, 500, discount=5, price_low=200)) 
> print(final_price(100, 200, 300, 400, 500, discount=5, price_high=200)) 
> print(final_price(100, 200, 300, 400, 500, discount=5, price_low=200, price_high=350))
> ```
> > [!abstract]+ Output
> > ```py
> > [95.0, 190.0, 285.0, 380.0, 475.0]
> > [190.0, 285.0, 380.0, 475.0]
> > [95.0, 190.0]
> > [190.0, 285.0]
> > ```

---
# Функции высших порядков

> [!info]+ Определение 
><u>**Функции высших порядков**</u> - это функции, которые принимают другие функции в качестве аргументов или возвращают функции как результат. Это позволяет создавать более модульный и масштабируемый код, поскольку функции могут быть легко комбинированы и переиспользованы.

## Примеры функций высшего порядка

### <mark style="background-color:#0E1053">" map() "</mark>
> [!info]+ 
> <mark style="background-color:#165474">" map() "</mark> - возвращает итератор, каждый элемент которого получен применением функции-обработчика к итерируемому объекту.

> [!example]+ 
> ```python
> def square(x): 
> 	return x ** 2 
> 	
> result = map(square, range(5)) 
> print(", ".join(str(x) for x in result))
> # Используем join, так как итератор
> ```
> > [!abstract]+ Output
> > ```py
> > 0, 1, 4, 9, 16
> > ```

 В `map()` можно использовать стандартные функции и методы Python.
> [!example]+ 
> Напишем программу, которая для списка строк выводит их в нижнем регистре
> ```python
> result = map(str.lower, ["abCD", "EFGh", "IJkl"]) 
> print("\n".join(result))
> ```
> > [!abstract]+ Output
> > ```py
> > abcd
> > efgh
> > ijkl
> > ```

Частым случаем применения функции `map()` является получение списка целых чисел из стандартного ввода:

```py
numbers = list(map(int, input().split()))
```

### <mark style="background-color:#0E1053">" filter() "</mark>
<mark style="background-color:#580297">" filter() "</mark> -  позволяет отобрать элементы из итерируемого объекта по некоторому критерию. Результат работы функции — <u>итератор</u>. Критерий отбора — <u>функция</u>, возвращающая значения логического типа.

Функция `filter()` последовательно **проверяет значение функции-критерия для каждого элемента**, и при значении `True` элемент попадает в выходной итератор

> [!example]+ 
> Программа, которая выберет из списка целых чисел только положительные
> ```python
> def only_pos(x): 
> 	return x > 0 
> result = filter(only_pos, [-1, 5, 6, -10, 0]) 
> print(", ".join(str(x) for x in result))
> ```
> > [!abstract]+ Output
> > ```py
> > 5, 6
> > ```

В качестве функции-критерия можно использовать **стандартные функции** и методы Python. 
Главное, чтобы эти функции и методы возвращали значения **логического типа данных** и могли работать с типами данных передаваемых в них аргументов. 

> [!example]+ 
> Программа, которая из всех символов строки выберет буквы. В примере мы используем метод `isalpha()` для типа данных `str`
> ```python
> result = filter(str.isalpha, "123ABcd()") 
> print("".join(result))
> ```
> > [!abstract]+ Output
> >```py
> > ABcd
> >```