
>[!accept]+ Let's write a program
>Смоделировать объекты класса **«Автомобиль»**. *При моделировании необходимо определить степень детализации объектов, которая зависит от действий, выполняемых этими объектами*
> - Все автомобили имеют <u>**разный цвет**</u>.
> - Двигатель <u>**можно запустить**</u>, *если в баке есть топливо.*
> - Двигатель <u>**можно заглушить**</u>.
> - На автомобиле <u>**можно уехать на N километров**</u> *при условии:* 
> 	- **двигатель запущен** и **запас топлива в баке и средний расход позволяют проехать этот путь.**
> - После поездки <u>**запас топлива уменьшается**</u> *в соответствии со средним расходом.*
> - Автомобиль <u>**можно заправить до полного бака**</u> *в любой момент времени.*
>
>> [!star]+ Solution
>> Выделим <u>важные свойства объектов класса</u>: 
>> 
>> - **цвет,** 
>> - **средний расход топлива,** 
>> - **объём топливного бака,** 
>> - **запас топлива,** 
>> - **общий пробег.**
>>
>> Определим, какие действия может выполнять объект: 
>> - **запустить двигатель**, 
>> - **проехать N километров**, 
>> - **остановить двигатель**, 
>> - **заправить автомобиль.** 

> [!bug]+ 
> Пока наши знания позволяют **использовать в качестве объекта в программе словарь**.

Попробуем описать объекты этого класса с помощью коллекций и функций:

> [!code]+
> ```python
> def create_car(color, consumption, tank_volume, mileage=0):  
>     return {  
>         "color": color,  
>         "consumption": consumption,  
>         "tank_volume": tank_volume,  
>         "reserve": tank_volume,  
>         "mileage": mileage,  
>         "engine_on": False  
>     }  
>   
>   
> def start_engine(car):  
>     if not car["engine_on"] and car["reserve"] > 0:  
>         car["engine_on"] = True  
>         return "Двигатель запущен."  
>     return "Двигатель уже был запущен."  
>   
>   
> def stop_engine(car):  
>     if car["engine_on"]:  
>         car["engine_on"] = False  
>         return "Двигатель остановлен."  
>     return "Двигатель уже был остановлен."  
>   
>   
> def drive(car, distance):  
>     if not car["engine_on"]:  
>         return "Двигатель не запущен."  
>     if car["reserve"] / car["consumption"] * 100 < distance:  
>         return "Малый запас топлива."  
>     car["mileage"] += distance  
>     car["reserve"] -= distance / 100 * car["consumption"]  
>     return f"Проехали {distance} км. Остаток топлива: {car['reserve']} л."  
>   
> def refuel(car):  
>     car["reserve"] = car["tank_volume"]  
>   
>   
> def get_mileage(car):  
>     return f"Пробег {car['mileage']} км."  
>   
> def get_reserve(car):  
>     return f"Запас топлива {car['reserve']} л."  
>   
> car_1 = create_car(color="black", consumption=10, tank_volume=55)  
>   
> print(start_engine(car_1))  
> print(drive(car_1, 100))  
> print(drive(car_1, 100))  
> print(drive(car_1, 100))  
> print(drive(car_1, 300))  
> print(get_mileage(car_1))  
> print(get_reserve(car_1))  
> print(stop_engine(car_1))  
> print(drive(car_1, 100))
> ```
> > [!output]+
> > ```py
> > Двигатель запущен.
> > Проехали 100 км. Остаток топлива: 45.0 л.
> > Проехали 100 км. Остаток топлива: 35.0 л.
> > Проехали 100 км. Остаток топлива: 25.0 л.
> > Малый запас топлива.
> > Пробег 300 км.
> > Запас топлива 25.0 л.
> > Двигатель остановлен.
> > Двигатель не запущен.
> > ```

> [!info]+ 
> Мы описали все действия над объектом с помощью функций. Такой подход в программировании называется <u>**процедурным**</u>
> 
> Он позволяет эффективно решать <mark style="background-color:#229400"> простые задачи</mark>. Однако при усложнении задачи и появлении новых объектов процедурный подход <mark style="background-color:#940014"> приводит к дублированию и ухудшению читаемости кода</mark>.

> [!success]+ 
> Объектно-ориентированное программирование (ООП) позволяет устранить недостатки процедурного подхода

---
[[1. Классы]]
[[2. Волшебные методы]]
[[3. Наследование]]
[[Основы Python/8. ООП (Объектно-ориентированное программирование)/Задачи|Задачи]]