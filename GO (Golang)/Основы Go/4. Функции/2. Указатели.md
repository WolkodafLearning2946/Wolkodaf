> [!info]+ Definition
> <u>**Указатели**</u> - значения, представляющие адреса переменных *(указывают на область памяти, в которой хранится переменная)*

Оператор `&` используется в Go для получения адреса переменной

> [!code]+
> ```go
> amount := 6
> fmt.Println(amount)
> fmt.Println(&amount)
> ```
> > [!output]+
> > ```
> > 6
> > 0x1040a124
> > ```

Адрес можно получить для переменной любого типа. Обратите внимание, все переменные имеют разные адреса

> [!code]+
> ```go
> var myInt int 
> fmt.Println(&myInt) 
> 
> var myFloat float64 
> fmt.Println(&myFloat) 
> 
> var myBool bool 
> fmt.Println(&myBool)
> ```
> > [!output]+
> > ```
> > 0x1040a128
> > 0x1040a140
> > 0x1040a148
> > ```

Зная адрес переменной, вы сможете **воспользоваться им для получения значения, хранящегося в переменной.**
![[Pasted image 20250213021208.png]]

---
## Типы указателей
Тип указателя состоит из знака `*` и типа переменной, на которую ссылается указатель. **Например,** тип указателя на переменную `int` записывается в виде `*int` *(читается «указатель на int»)*

==reflect.TypeOf== - функция, с помощью которой можно вывести типы указателей из приведённой ранее программы

> [!code]+
> ```go
> package main 
> import ( 
> 	"fmt" 
> 	"reflect" 
> ) 
> func main() { 
> 	var myInt int 
> 	fmt.Println(reflect.TypeOf(&myInt)) 
> 	
> 	var myFloat float64 
> 	fmt.Println(reflect.TypeOf(&myFloat)) 
> 	
> 	var myBool bool 
> 	fmt.Println(reflect.TypeOf(&myBool)) }
> ```
> > [!output]+
> > ```
> > *int
> > *float64
> > *bool
> > ```

В программе можно объявлять переменные, содержащие указатели. В таких переменных могут храниться только указатели на один конкретный тип переменной.

> [!code]+
> ```go
> var myInt int 
> var myIntPointer *int // Объявление переменной, содержащей указатель на int
> myIntPointer = &myInt // Указатель присваивается переменной
> fmt.Println(myIntPointer) 
> 
> var myFloat float64 
> var myFloatPointer *float64 // Объявление переменной для хранения указателя на float64
> myFloatPointer = &myFloat // Указатель присваивается переменной
> fmt.Println(myFloatPointer)
>
> var myBool bool 
> myBoolPointer := &myBool // Короткое объявление переменной-указателя
> fmt.Println(myBoolPointer)
> ```
> > [!output]+
> > ```
> > 0x1040a128
> > 0x1040a140
> > ```


---
## Чтение или изменение значения по указателю

> [!code]+
> ```go
> myInt := 4 
> myIntPointer := &myInt   
> fmt.Println(myIntPointer) // Выводится сам указатель
> fmt.Println(*myIntPointer) // Выводится значение, на которое ссылается указатель
>   
> myFloat := 98.6 
> myFloatPointer := &myFloat   
> fmt.Println(myFloatPointer) // Выводится сам указатель
> fmt.Println(*myFloatPointer) // Выводится значение, на которое ссылается указатель
>   
> myBool := true   
> myBoolPointer := &myBool   
> fmt.Println(myBoolPointer) // Выводится сам указатель
> fmt.Println(*myBoolPointer) // Выводится значение, на которое ссылается указатель
> ```
> > [!output]+
> > ```
> > 0x1040a124
> > 4
> > 0x1040a140
> > 98.6
> > 0x1040a150
> > true
> > ```

Оператор `*` может использоваться для обновления значения по указателю.

> [!code]+
> ```go
> myInt := 4 
> fmt.Println(myInt) 
> myIntPointer := &myInt 
> *myIntPointer = 8 // Новое значение присваивается переменной, на которую ссылается указатель (myInt)
> fmt.Println(*myIntPointer) // Выводится значение переменной, на которую ссылается указатель
> fmt.Println(myInt) // Значение переменной выводится напрямую
> ```
> > [!output]+
> > ```py
> > 4 # Исходное значение myInt
> > 8 # Результат обновления *myPointer
> > 8 # Обновление значения myInt (то же, что *myIntPointer).
> > ```

---
## Использование указателей с функциями

> [!code]+
> ```go
> func createPointer() *float64 { // Объявляем, что функция возвращает указатель на float64
> 	var myFloat = 98.5
> 	return &myFloat // Возвращает указатель заданного типа
> }
> func main() {
> 	var myFloatPointer *float64 = createPointer() // Назначает возращённый указатель переменной
> 	fmt.Println(*myFloatPointer) // Выводим значение, на которое ссылается указатель
> }
> ```
> > [!output]+
> > ```
> > 98.5
> > ```

---

В Go можно вернуть указатель на переменную, локальную по отношению к функции. И хотя эта переменная уже **не находится в области видимости**, пока у вас есть указатель, Go предоставит вам доступ к значению этой переменной.
### Пример:

Функция `double` - принимает значение типа `int` и умножает его на `2`. Мы хотим передавать это значение и удваивать его. Но в Go **параметры функции получают копию любых аргументов от вызывающей стороны.** <mark style="background: #FF5582A6;">Наша функция удваивает копию значения и оставляет оригинал нетронутым!</mark>

> [!code]+
> ```go
> func main() { 
> 	amount := 6 
> 	double(amount) // Передаём аргумент функции
> 	fmt.Println(amount) // Выводит исходное значение!!
> 	
> } 
> 
> func double(number int) { // Параметр `number` настраивает копию аргумента
> 	number *= 2 // Изменяет скопированное значение, а не исходное!!
> }
> ```
> > [!output]+
> > ```py
> > 6 # Выводится исходное значение!!
> > ```

Если передать указатель функции, а затем изменить значение, на которое он ссылается, <mark style="background: #12AF19;">изменения будут действовать и за пределами функции.</mark>

> [!code]+
> ```go
> func main() { 
> 	amount := 6 
> 	double(&amount) // Вместо значения переменной передаётся указатель на неё
> 	fmt.Println(amount) 
> } 
> func double(number *int) { // Вместо значения `int` получает указатель
> 	*number *= 2 // Обновляем значение, на которое ссылается указатель
> }
> ```
> > [!output]+
> > ```py
> > 12 # Выводится удвоенное значение
> > ```

>[!warning]+ <u>Будьте осторожны!</u> Чтобы вызвать метод, которому требуется получатель-указатель, необходимо иметь возможность получить указатель на значение!
> Вы можете получать указатели **только на значения, хранящиеся в переменных**. При попытке получить адрес значения, не хранящегося в переменной, **вы получите сообщение об ошибке**:
> 
> >[!code]+
> >```go
> > &MyType("a value")
> >```
> > > [!output]+
> > > ```
> > > cannot take the addressof MyType("a value")
> > > ```