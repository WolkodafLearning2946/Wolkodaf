> [!info]+ Definition
> Сегменты и карты не позволяют смешивать разные типы. Тем не менее это возможно при использовании типа данных, называемого **структурой**
> **Структуры формируются из значений МНОГИХ типов**

>[!code]+ `struct` - Структура
>```go
> struct { // Ключевое слово struct
> 	field1 string // Имя поля, тип поля
> 	field2 int // Имя поля, тип поля
> }
>```
>В фигурных скобках определяются одно или несколько **полей**: *значений, группируемых в структуре.*

Тип структуры может использоваться в качестве типа объявляемой переменной

> [!code]+
> Переменная **«myStruct»** может хранить структуры, состоящие из **поля float64** с именем <u>«number»</u>, **поля string** с именем <u>«word»</u> и **поля bool** с именем <u>«toggle»</u>.
> ```go
> var myStruct struct {  
>     number float64  
>     word   string  
>     toggle bool  
> }  
> fmt.Printf("%#v\n", myStruct) // Значение структуры выводится в том виде, в котором оно записывается в коде Go
> ```
> > [!output]+
> > ```
> > struct { number float64; word string; toggle bool }{number:0, word:"", toggle:false}
> > ```

>[!relax]- Не беспокойтесь о количестве пробелов между именами и типами полей структур
>Когда вы <u>выполните команду `go fmt`</u> для своего файла (а это следует делать всегда) или <u>сохраняете код</u>, **команда вставит дополнительные пробелы**, чтобы все типы были выровнены по вертикали. 
> 
> <u>**Выравнивание всего лишь упрощает чтение кода: его смысл при этом совершенно не изменяется!**</u>
>

---
Для обозначения полей, "принадлежащих" структуре. Будем использовать оператор **"точка"**
>[!code]+ Этот синтаксис подходит как для присваивания значений, так и для их чтения.
>```go
> myStruct.number = 3.14 // значение-структура.имя_поля = присваемое значение 
> fmt.Println(myStruct.number) // (значение-структура.имя_поля)
>```

---
## Пример
Напишем структуру, которая будет описывать подписчиков журнала:
> [!code]+
> ```go
> var subscriber struct {  
>     name   string  
>     rate   float64  
>     active bool  
> }  
> subscriber.name = "Aman Singh"  
> subscriber.rate = 4.99  
> subscriber.active = true  
> fmt.Println("Name:", subscriber.name)  
> fmt.Println("Monthly rate:", subscriber.rate)  
> fmt.Println("Active?", subscriber.active)
> ```
> > [!output]+
> > ```
> > Name: Aman Singh
> > Monthly rate: 4.99
> > Active? true
> > ```

> [!warning]+ А если у нас будет несколько подписчиков, то нужно будет для каждого отдельно писать структуру?

> [!success]+ [[2. Определения типов|Решение есть!]]

---
[[2. Определения типов]]
[[3. Применение указателей в структурах]]
[[4. Перемещение типа структуры в другой пакет]]

---
## Литералы структур

Сначала **указывается тип**, за ним идут фигурные скобки. В фигурных скобках можно **задать значения полей структуры** (всех или некоторых); <u>для каждого поля указывается имя, двоеточие и значение</u>. Если вы указываете несколько полей, разделите их запятыми.

>[!code]+
>```go
> myCar := car{name: "Corvette", topSpeed: 337}
>```
> `car` - тип структуры
> `name`, `topSpeed` - поля
> `"Corvette"`, `337` - значения

> [!code]+ Let's rewrite the code
> ```go
> subscriber := function.Subscriber{Name: "Aman Singh", Rate: 4.99, Active: true}
> 
> fmt.Println("Name:", subscriber.Name) 
> fmt.Println("Rate:", subscriber.Rate) 
> fmt.Println("Active:", subscriber.Active)
> ```
> > [!output]+
> > ```
> > Name: Aman Singh
> > Rate: 4.99
> > Active: true
> > ```


Некоторые *(и даже все)* поля не нужно указывать в фигурных скобках. **Пропущенные поля инициализируются нулевыми значениями для своих типов.**

> [!code]+
> ```go
> subscriber := function.Subscribe{Rate: 4.99}  // Значение передаётся только полю Rate
>   
> fmt.Println("Name:", subscriber.Name)  // Нулевое значение
> fmt.Println("Rate:", subscriber.Rate)  
> fmt.Println("Active:", subscriber.Active) // Нулевое значение
> ```
> > [!output]+
> > ```
> > Name: 
> > Rate: 4.99
> > Active: false
> > ```

---
[[5. Практика]]