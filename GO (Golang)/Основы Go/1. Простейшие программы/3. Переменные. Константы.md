# Способы объявления переменных

> [!abstract]+ Способы объявления переменных
> ```go
> func main() {
> ```
> **Способ 1**:
> Пишем ключевое слово `var` *(сокращение *`variable`*)*; указываем название переменной *(произвольное)*; указываем тип данных
> ```go
> var age int  
> age = 10  
> fmt.Println(age)
> ```
> **Способ 2:**
> Делаем то же, только в одну строчку
> ```go
> var age2 int = 10
> fmt.Println(age2)
> ```
> **Способ 3:**
> Делаем то же, но не указываем тип данных, так как компилятор сам догадывается, какой должен быть тип данных *(указываем* `10` => `int`*; указываем* `10.5` => `float64`*)*
> ```go
> var age3 = 10
> fmt.Println(age3)
> ```
> **Способ 4:** <mark style="background: #73AE2C;">Самый лучший</mark>
> Не нужно указывать ключевое слово `var`
> ```go
> age4 := 10
> fmt.Println(age4)
> ```
> **Способ 5:**
> <u>При использовании 4 способа</u>, **компилятор решает сам, какой тип данных нужно поставить**, поэтому, мы можем сами поставить тот тип данных, который нам нужен
> ```go
> age5 := float64(10)
> fmt.Println(age5)
> ```
> **Способ 6:**
> Если нужно объявить несколько переменных, то можем указать их через одну строчку
> ```go
> x, y, z := 1, 2, 3
> fmt.Println(x, y, z)
> ```
> ```go
> }
> ```

> [!warning]+ ВАЖНО!!! переменную нельзя объявить дважды
> Действительно, если дважды объявить одно имя переменной в одной области видимости, компилятор выдаст сообщение об ошибке:
> > [!code]+
> > ```go
> > a := 1
> > a := 2
> > ```
> > > [!output]+
> > >```
> > > no new variables on left side of :=
> > >```
>
> Но **если хотя бы одно имя переменной** в коротком объявлении **является новым, такая запись допустима.** Новые имена переменных интерпретируются как <u>объявление</u>, а существующие — как <u>присваивание</u>.
> > [!code]+
> > ```go
> > a := 1 // объявляем `a`
> > b, a := 2, 3 // объявляем `b`, присваиваем `a`
> > a, c := 4, 5  // Присваиваем `a`, объявляем `c`
> > fmt.Println(a, b, c)
> > ```
> > > [!output]+
> > >```go
> > > 4 2 5
> > >```

---
# Типы данных

### Числовые
> [!info]+ `int` - Integer
> Все числа без плавающей запятой:
> ```go
> age := int(10)
> ```
> Если же мы понимаем, что будем использовать не очень большие диапазоны чисел, то можем указать, сколько битов будем использовать
> ```go
> age := int8(10) // Диапазон (-128, 127)
> age2 := int16(10) // Диапазон (-32768, 32767)
> age3 := int32(10) // Диапазон (-2147483648, 2147483647)
> age4 := int64(10) // Диапазон (-9223372036854775808, 9223372036854775807)
> ```

> [!info]+ `uint`
> Работает также, как `integer`, но диапазон чисел начинается с нуля
> ```go
> age := uint8(10) // Диапазон (0, 255)
> age := uint16(10) // Диапазон (0, 65535)
> age := uint32(10) // Диапазон (0, 4294967295)
> age := uint64(10) // Диапазон (0, 18446744073709551615)
> ```

> [!info]+ `float`
> Все дробные числа (числа с плавающей запятой)
> ```go
> age := float64(10.5)
> ```
> > [!tip]+ Advice
> > Чтобы явно не указывать тип данных `float`, то:
> > ```go
> > age := 10.
> > ```

### Булевы
> [!info]+ `bool` - Boolean
> `true` - правда (верно)
> `false` - не правда
> >[!code]+
> >```go
> > func main() {
> > 	age := 20
> >     isAdult := bool(age > 10)  
> >     fmt.Println(isAdult)  
> > }
> > ```
> > > [!output]+
> > > ```go
> > > true
> > > ```
### Строчные
> [!info]+ `string` - Строки
> Набор 8-битовых байт (у каждого символа есть свой 8-битный код)
> ![[Pasted image 20250203193413.png]]
> >[!code]+
> >```go
> > func main() {  
> >     name := string("masha")  
> >     fmt.Println(string(name[0]))  
> >     fmt.Println(string(name[1]))  
> >     fmt.Println(string(name[2]))  
> >     fmt.Println(string(name[3]))  
> >     fmt.Println(string(name[4]))  
> > }
> > ```
> > > [!output]+
> > > ```go
> > > m
> > > a
> > > s
> > > h
> > > a
> > > ```
> 
> Если мы не применим `string` к индексам, то вернётся 8-битный код указанного символа
> >[!code]+
> >```go
> > func main() {  
> >     name := string("masha")  
> >     fmt.Println(name[0])  
> >     fmt.Println(name[1])  
> >     fmt.Println(name[2])  
> >     fmt.Println(name[3])  
> >     fmt.Println(name[4])  
> > }
> > ```
> > > [!output]+
> > > ```go
> > > 109
> > > 97
> > > 115
> > > 104
> > > 97
> > > ```

---
> [!info]+ `byte`
> Обратим внимание, что при возврате `name[0]` мы получили `109`, что аналогично типу данных `int`, но это число **предназначено** не для того, чтобы с ним выполнять математические операции, а для того, **чтобы отражать число, которое соответствует этому символу.**
> Если перейдём в тип данных `byte`, то увидим:
> ```go
> type byte = uint8 // это значит, что тип данных `byte` полностью соответствует типу данных `uint8`
> ```
> > [!example]+ 
> > ```go
> > age := uint8(10)
> > age2 := byte(10)
> > ```

> [!info]+ `rune`
> То же самое предназначение, что и для `byte`. Различие заключается в:
> ```go
> type rune =  int32 // используется более широкий диапазон, в отличии от `byte`
> ```
> Создан для отображения новых символов (не цифр и не английских букв), для которых требуется не 1 байт, а несколько

> [!example]+ General example
> <mark style="background: #73AE2C;">Без ошибки</mark>:
> >[!code]+
> > ```go
> > asd := byte('m') // английская буква "m"
> > fmt.Println(asd)
> > ```
> 
> > [!output]+
> > ```go
> > 109
> > ```
> 
> 
> <mark style="background: #FF5582A6;">С ошибкой</mark>
> > [!code]+
> > ```go
> > asd := byte('м') // русская буква "м"
> > fmt.Println(asd)
> > ```
> 
> > [!output]+
> > ```
> > constant 1084 overflows byte
> > ```

---

# Константы

>[!code]+ Способ задания константы
>```go
> const TriangleSides int = 3
>```
> Как и при объявлении переменных, **тип** можно опустить, он **будет автоматически определён по присваиваемому значению:**
>```go
> const SquareSides = 4
>```

> [!failure]+ Попытка присвоить новое значение константе приведет к ошибке компиляции

Если ваша программа включает **«фиксированные»** значения литералов (особенно если эти значения используются в нескольких местах), подумайте о том, чтобы заме-
нить их константами (даже если программа не разбита на пакеты).

>[!code]+ Example
>```go
> package dates
> 
> func WeeksToDays(weeks int) int { // Получаем кол-во недель
> 	return weeks * 7 // Умножаем на количество дней в неделе,
> чтобы вычислить общее количество дней
> }
> func DaysToWeeks(days int) float64 { // Получаем кол-во недель
> 	return float64(days) / float64(7) // Делим на количество дней в неделе, чтобы получить количество недель.
> }
>
>```
> Заменяя литералы константой DaysInWeek, мы тем самым документируем их смысл

Константа объявляется **за пределами любых функций, на уровне пакета.** *И хотя константу можно объявить внутри функции, это ограничит ее область видимости блоком этой функции.*

>[!code]+
>```go
> package dates
> 
> const DaysInWeek int = 7 // Объявляем константу
> 
> func WeeksToDays(weeks int) int {
> 	return weeks * DaysInWeek // Константа используется вместо целочисленного литерала
> }
> func DaysToWeeks(days int) float64 {
> return float64(days) / float64(DaysInWeek) // Константа используется вместо целочисленного литерала
> }
>```

Вариант с объявлением констант на уровне пакета <u>гораздо более типичен</u>, так как эти константы будут доступны для всех функций этого пакета.

>[!code]+ Example
>```go
> package dates
> 
> const DaysInWeek int = 7
> 
> func WeeksToDays(weeks int) int {
> 	return weeks * DaysInWeek
> }
> 
> func DaysToWeeks(days int) float64 {
> 	return float64(days) / float64(DaysInWeek)
> }
>```

Как и в случае с переменными и функциями, константа, имя которой начинается с буквы верхнего регистра, экспортируется, и к ней можно будет обращаться из других пакетов с уточнением имени.