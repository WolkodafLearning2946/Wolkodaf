>[!code]+ Способ задания сегмента
>```go
> var mySlice []string // ПУСТАЯ ПАРА КВАДРАТНЫХ СКОБОК
>```

**В отличие от переменных для массивов**, объявление переменной для сегмента не приводит к автоматическому созданию сегмента. Для этого следует вызвать <u>встроенную функцию</u> ==make==.

>[!code]+
>```go
> var notes []string // объявление переменной для сегмента
> notes = make([]string, 7) // создание сегмента из семи строк
>```

Объявлять переменную и создавать сегмент по отдельности <u>необязательно</u>
>[!code]+
>```go
> primes := make([]int, 5) // создаёт сегмент из пяти целых чисел и присваивает его переменной
>```

>[!star]+ Плюшки, похожие на массивы
> - Встроенная функция `len` для сегментов работает так же, как и для массивов
> - Работа с индексами элементов такая же, как у массивов
> - Циклы `for` и `for...range` работают с сегментами точно так же, как и с массивами

>[!code]+ Литералы сегментов
> Когда известны (необязательно, что все) элементы сегмента:
>```go
> notes := []string{"do", "re", "mi", "fa", "so", "la", "ti"} // значения присваиваются с помощью литерала сегмента  
> fmt.Println(notes[3], notes[6], notes[0])  
> primes := []int{ // многострочный литерал сегмента  
>     2,  
>     3,  
>     5,  
> }  
> fmt.Println(primes[0], primes[1], primes[2])
>```
> > [!output]+
> >```
> > fa ti do
> > 2 3 5
> >```

---
## Оператор сегмента

Каждый массив существует на основе базового массива. Данные сегмента на самом деле хранятся в базовом массиве, а сегмент всего лишь предоставляет «окно» для работы с некоторыми *(или всеми)* элементами массива.
Когда вы используете функцию `make` или литерал сегмента для создания сегмента, **базовый массив при этом создается автоматически** *(и вы не можете обратиться к нему иначе как через сегмент)*. Но вы также можете создать массив самостоятельно, а затем создать сегмент на основе этого массива при помощи <u>оператора сегмента</u>

>[!code]+
>```go
> mySlice := myArray[1:3]
>```
> Работает, как [[2. Операции с массивами|срезы]] в python
> > [!code]+
> > ```go
> > underlyingArray := [5]string{"a", "b", "c", "d", "e"} 
> > slice1 := underlyingArray[0:3] 
> > fmt.Println(slice1)
> > ```
> > > [!output]+
> > > ```
> > > [a b c]
> > > ```
> 
> > [!code]+
> > ```go
> > underlyingArray := [5]string{"a", "b", "c", "d", "e"} 
> > i, j := 1, 4 slice2 := underlyingArray[i:j] 
> > fmt.Println(slice2)
> > ```
> > > [!output]+
> > > ```
> > > [b c d]
> > > ```

> [!warning]+ При изменении базового массива изменяется сегмент
> **А теперь один нюанс:** поскольку сегмент является всего лишь «окном» для работы с содержимым массива, в случае изменения базового массива **эти изменения также отразятся в сегменте!**
> > [!code]+
> > ```go
> > array1 := [5]string{"a", "b", "c", "d", "e"}  
> > slice1 := array1[0:3]  
> > array1[1] = "X"  
> > fmt.Println(array1)  
> > fmt.Println(slice1)
> > ```
> > > [!output]+
> > > ```
> > > [a X c d e]
> > > [a X c]
> > > ```
> 
> Из-за этих потенциальных проблем обычно **рекомендуется создавать сегменты с использованием make или литерала сегмента** *(вместо того, чтобы создать массив и применять к нему оператор сегмента)*. С `make` и литералами сегментов вам никогда не приходится иметь дела с базовым массивом.

---
## Расширение сегментов
==append(segment, *значения*)== - встроенная функция, которая получает сегмент и одно или несколько значений, которые присоединяются в конец сегмента. **Функция возвращает новый, расширенный сегмент со всеми элементами исходного сегмента и новыми элементами, добавленными в его конец**

> [!code]+
> ```go
> slice := []string{"a", "b"}  
> fmt.Println(slice, len(slice))  
> slice = append(slice, "c")  
> fmt.Println(slice, len(slice))  
> slice = append(slice, "d", "e")  
> fmt.Println(slice, len(slice))
> ```
> > [!output]+
> > ```
> > [a b] 2
> > [a b c] 3
> > [a b c d e] 5
> > ```

> [!danger]+ 
> >[!code]+
> >```go
> > s1 := []string{"s1", "s1"} 
> > s2 := append(s1, "s2", "s2") 
> > s3 := append(s2, "s3", "s3") 
> > s4 := append(s3, "s4", "s4") 
> > fmt.Println(s1, s2, s3, s4) 
> > s4[0] = "XX" 
> > fmt.Println(s1, s2, s3, s4)
> >```
> > >[!output]+
> > >```
> > > [s1 s1] [s1 s1 s2 s2] [s1 s1 s2 s2 s3 s3] [s1 s1 s2 s2 s3 s3 s4 s4]
> > > [s1 s1] [s1 s1 s2 s2] [XX s1 s2 s2 s3 s3] [XX s1 s2 s2 s3 s3 s4 s4]
> > >```
>
> **Что произошло?** Когда значение присваивается элементу сегмента `s4`, мы видим, что изменения отражаются в `s3`, потому что `s4` и `s3` **используют один и тот же базовый массив**. Однако изменения не отражаются в `s2` или `s1`, потому что **они используют другой базовый массив.**
> >[!tip]-
> > **Базовый массив сегмента не может увеличиваться в размерах.** Если в массиве не остается места для добавления элементов, **все элементы копируются в новый, больший массив**, а сегмент обновляется, чтобы он базировался на новом массиве.
> >
> > Но поскольку все это происходит где-то за кулисами внутри функции append, невозможно простым способом определить, имеет ли возвращенный сегмент тот же базовый массив, как и переданный сегмент, или другой.

> [!success]+ Solution
> **По этой причине при вызове** `append` **возвращаемое значение обычно присваивается той же переменной сегмента**, которая была передана append. Если в программе хранится только один сегмент, то вам не придется беспокоиться о том, используют ли два сегмента один базовый массив!
> >[!code]+
> > Сегменты, возвращаемые «append», присваиваются той же переменной
> >```go
> > s1 := []string{"s1", "s1"} 
> > s1 = append(s1, "s2", "s2") 
> > s1 = append(s1, "s3", "s3") 
> > s1 = append(s1, "s4", "s4") 
> > fmt.Println(s1)
> >```
> > > [!output]+
> > > ```py
> > > [s1 s1 s2 s2 s3 s3 s4 s4] # и никаких неприятных сюрпризов
> > > ```